<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>Facial Recognition: /mnt/c/ABC/CS/github/Facial-Recognition/src/libs/linalg.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Facial Recognition
   </div>
   <div id="projectbrief">UsePCAtoperformfacialrecognition</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Macros</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a class="el" href="dir_87a455bccb09a92130c26a11a880c98a.html">libs</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">linalg.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>File containing common linear algebra functions.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;stdlib.h&gt;</code><br/>
<code>#include &lt;stdio.h&gt;</code><br/>
<code>#include &lt;string.h&gt;</code><br/>
<code>#include &lt;math.h&gt;</code><br/>
<code>#include &lt;time.h&gt;</code><br/>
<code>#include &lt;assert.h&gt;</code><br/>
</div><div class="textblock"><div class="dynheader">
Include dependency graph for linalg.h:</div>
<div class="dyncontent">
<div class="center"><img src="linalg_8h__incl.png" border="0" usemap="#_2mnt_2c_2ABC_2CS_2github_2Facial-Recognition_2src_2libs_2linalg_8h" alt=""/></div>
<map name="_2mnt_2c_2ABC_2CS_2github_2Facial-Recognition_2src_2libs_2linalg_8h" id="_2mnt_2c_2ABC_2CS_2github_2Facial-Recognition_2src_2libs_2linalg_8h">
</map>
</div>
</div><div class="textblock"><div class="dynheader">
This graph shows which files directly or indirectly include this file:</div>
<div class="dyncontent">
<div class="center"><img src="linalg_8h__dep__incl.png" border="0" usemap="#_2mnt_2c_2ABC_2CS_2github_2Facial-Recognition_2src_2libs_2linalg_8hdep" alt=""/></div>
<map name="_2mnt_2c_2ABC_2CS_2github_2Facial-Recognition_2src_2libs_2linalg_8hdep" id="_2mnt_2c_2ABC_2CS_2github_2Facial-Recognition_2src_2libs_2linalg_8hdep">
<area shape="rect" id="node2" href="linalg_8c.html" title="File containing common linear algebra functions. " alt="" coords="5,213,160,269"/><area shape="rect" id="node3" href="tiff__util_8h.html" title="File containing common libtiff wrapper functions. " alt="" coords="185,109,340,165"/><area shape="rect" id="node5" href="facerec_8c.html" title="File containing the main function. " alt="" coords="365,213,520,269"/><area shape="rect" id="node4" href="tiff__util_8c.html" title="File containing common libtiff wrapper functions. " alt="" coords="185,213,340,269"/></map>
</div>
</div>
<p><a href="linalg_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct__vector.html">_vector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">represents a vector padding is to make sure that matrix and vector both have the same byte size and allignment between matrix and vector they are able to be casted into one another  <a href="struct__vector.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct__matrix.html">_matrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">represents a matrix between matrix and vector they are able to be casted into one another  <a href="struct__matrix.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ae0e32e641b8137c777d52988864296e3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae0e32e641b8137c777d52988864296e3"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linalg_8h.html#ae0e32e641b8137c777d52988864296e3">MAT</a>(m, x, y)&#160;&#160;&#160;(m-&gt;data[(x * m-&gt;col) + y])</td></tr>
<tr class="memdesc:ae0e32e641b8137c777d52988864296e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">macro for element access in a matrix struct <br/></td></tr>
<tr class="separator:ae0e32e641b8137c777d52988864296e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03e904294c904b01194a25323fc2f6ec"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a03e904294c904b01194a25323fc2f6ec"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linalg_8h.html#a03e904294c904b01194a25323fc2f6ec">VEC</a>(v, x)&#160;&#160;&#160;(v-&gt;data[x])</td></tr>
<tr class="memdesc:a03e904294c904b01194a25323fc2f6ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">macro for element access in a vector struct <br/></td></tr>
<tr class="separator:a03e904294c904b01194a25323fc2f6ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a07a01529159cc35e78c1f7731ac7bda6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a07a01529159cc35e78c1f7731ac7bda6"></a>
typedef struct <a class="el" href="struct__vector.html">_vector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linalg_8h.html#a07a01529159cc35e78c1f7731ac7bda6">vector</a></td></tr>
<tr class="memdesc:a07a01529159cc35e78c1f7731ac7bda6"><td class="mdescLeft">&#160;</td><td class="mdescRight">represents a vector padding is to make sure that matrix and vector both have the same byte size and allignment between matrix and vector they are able to be casted into one another <br/></td></tr>
<tr class="separator:a07a01529159cc35e78c1f7731ac7bda6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc75382643898dd572498a574bf891c7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abc75382643898dd572498a574bf891c7"></a>
typedef struct <a class="el" href="struct__matrix.html">_matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linalg_8h.html#abc75382643898dd572498a574bf891c7">matrix</a></td></tr>
<tr class="memdesc:abc75382643898dd572498a574bf891c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">represents a matrix between matrix and vector they are able to be casted into one another <br/></td></tr>
<tr class="separator:abc75382643898dd572498a574bf891c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a7040be230e99648e77b0932600bf55ef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="linalg_8h.html#a07a01529159cc35e78c1f7731ac7bda6">vector</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linalg_8h.html#a7040be230e99648e77b0932600bf55ef">vector_create</a> (size_t size)</td></tr>
<tr class="memdesc:a7040be230e99648e77b0932600bf55ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a vector this function will malloc the exact space for the required dimensions.  <a href="#a7040be230e99648e77b0932600bf55ef">More...</a><br/></td></tr>
<tr class="separator:a7040be230e99648e77b0932600bf55ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7821976cc30bc3131f3646bec1992d91"><td class="memItemLeft" align="right" valign="top"><a class="el" href="linalg_8h.html#abc75382643898dd572498a574bf891c7">matrix</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linalg_8h.html#a7821976cc30bc3131f3646bec1992d91">matrix_create</a> (size_t row, size_t col)</td></tr>
<tr class="memdesc:a7821976cc30bc3131f3646bec1992d91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a matrix this function will malloc the exact space for the required dimensions.  <a href="#a7821976cc30bc3131f3646bec1992d91">More...</a><br/></td></tr>
<tr class="separator:a7821976cc30bc3131f3646bec1992d91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a5d3412faa2267345b3a7d1ca6f58c1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="linalg_8h.html#abc75382643898dd572498a574bf891c7">matrix</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linalg_8h.html#a8a5d3412faa2267345b3a7d1ca6f58c1">vec_to_mat</a> (<a class="el" href="linalg_8h.html#a07a01529159cc35e78c1f7731ac7bda6">vector</a> *vec, int orientation)</td></tr>
<tr class="memdesc:a8a5d3412faa2267345b3a7d1ca6f58c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts vector into matrix this function will "cast" the vector into a matrix by using the fact that they both have the same size. when calling this function, calling free() on the matrix will free the vector and vice versa.  <a href="#a8a5d3412faa2267345b3a7d1ca6f58c1">More...</a><br/></td></tr>
<tr class="separator:a8a5d3412faa2267345b3a7d1ca6f58c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9059a420799b3aa9c04d5dd469523d91"><td class="memItemLeft" align="right" valign="top"><a class="el" href="linalg_8h.html#a07a01529159cc35e78c1f7731ac7bda6">vector</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linalg_8h.html#a9059a420799b3aa9c04d5dd469523d91">mat_to_vec</a> (<a class="el" href="linalg_8h.html#abc75382643898dd572498a574bf891c7">matrix</a> *mat)</td></tr>
<tr class="memdesc:a9059a420799b3aa9c04d5dd469523d91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts matrix into vector this function will "cast" the matrix into a vector by using the fact that they both have the same size. when calling this function, calling free() on the vector will free the matrix and vice versa. the input matrix can only be a matrix with dimensions 1 X N (a row matrix)  <a href="#a9059a420799b3aa9c04d5dd469523d91">More...</a><br/></td></tr>
<tr class="separator:a9059a420799b3aa9c04d5dd469523d91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41ab46fdaa678c67aef38d873870a98d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linalg_8h.html#a41ab46fdaa678c67aef38d873870a98d">matrix_reshape</a> (<a class="el" href="linalg_8h.html#abc75382643898dd572498a574bf891c7">matrix</a> *mat, size_t row, size_t col)</td></tr>
<tr class="memdesc:a41ab46fdaa678c67aef38d873870a98d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reshapes the matrix this function will reshape the matrix in constant time.  <a href="#a41ab46fdaa678c67aef38d873870a98d">More...</a><br/></td></tr>
<tr class="separator:a41ab46fdaa678c67aef38d873870a98d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc298e7d7d6a208e71ef073948b651d2"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linalg_8h.html#afc298e7d7d6a208e71ef073948b651d2">dot_product</a> (const double *left, const double *right, int length)</td></tr>
<tr class="memdesc:afc298e7d7d6a208e71ef073948b651d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs dot product on two double* this function will malloc for the user a double arrays must be of same size.  <a href="#afc298e7d7d6a208e71ef073948b651d2">More...</a><br/></td></tr>
<tr class="separator:afc298e7d7d6a208e71ef073948b651d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c350b8673e50738602aa10cd6a86924"><td class="memItemLeft" align="right" valign="top"><a class="el" href="linalg_8h.html#a07a01529159cc35e78c1f7731ac7bda6">vector</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linalg_8h.html#a0c350b8673e50738602aa10cd6a86924">vecscalar_multiply</a> (const <a class="el" href="linalg_8h.html#a07a01529159cc35e78c1f7731ac7bda6">vector</a> *vec, const double scalar)</td></tr>
<tr class="memdesc:a0c350b8673e50738602aa10cd6a86924"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs scalar multiplication of a vector this function will malloc for the user a vector*.  <a href="#a0c350b8673e50738602aa10cd6a86924">More...</a><br/></td></tr>
<tr class="separator:a0c350b8673e50738602aa10cd6a86924"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bc6dcc923c28a9d6f0ff38bd5de55f5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="linalg_8h.html#a07a01529159cc35e78c1f7731ac7bda6">vector</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linalg_8h.html#a2bc6dcc923c28a9d6f0ff38bd5de55f5">vecscalar_divide</a> (const <a class="el" href="linalg_8h.html#a07a01529159cc35e78c1f7731ac7bda6">vector</a> *vec, const double scalar)</td></tr>
<tr class="memdesc:a2bc6dcc923c28a9d6f0ff38bd5de55f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs scalar division of a vector this function will malloc for the user a vector*.  <a href="#a2bc6dcc923c28a9d6f0ff38bd5de55f5">More...</a><br/></td></tr>
<tr class="separator:a2bc6dcc923c28a9d6f0ff38bd5de55f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4af2cd71186eeb14f970f97a27fbcef0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="linalg_8h.html#a07a01529159cc35e78c1f7731ac7bda6">vector</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linalg_8h.html#a4af2cd71186eeb14f970f97a27fbcef0">vecmat_multiply</a> (const <a class="el" href="linalg_8h.html#a07a01529159cc35e78c1f7731ac7bda6">vector</a> *vec, const <a class="el" href="linalg_8h.html#abc75382643898dd572498a574bf891c7">matrix</a> *mat)</td></tr>
<tr class="memdesc:a4af2cd71186eeb14f970f97a27fbcef0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs vector matrix multiplication this function will malloc for the user a vector* if the vector is of size M and the matrix size M by N, the resulting column vector will be of size N.  <a href="#a4af2cd71186eeb14f970f97a27fbcef0">More...</a><br/></td></tr>
<tr class="separator:a4af2cd71186eeb14f970f97a27fbcef0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af88415d8996030537851e2c48d5337c4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="linalg_8h.html#a07a01529159cc35e78c1f7731ac7bda6">vector</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linalg_8h.html#af88415d8996030537851e2c48d5337c4">matvec_multiply</a> (const <a class="el" href="linalg_8h.html#abc75382643898dd572498a574bf891c7">matrix</a> *mat, const <a class="el" href="linalg_8h.html#a07a01529159cc35e78c1f7731ac7bda6">vector</a> *vec)</td></tr>
<tr class="memdesc:af88415d8996030537851e2c48d5337c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs matrix vector multiplication this function will malloc for the user a vector* if the matrix is of size M by N and the vector N, the resulting row vector will be of size M.  <a href="#af88415d8996030537851e2c48d5337c4">More...</a><br/></td></tr>
<tr class="separator:af88415d8996030537851e2c48d5337c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c4e05af95e01c11963c912837d0d35b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linalg_8h.html#a3c4e05af95e01c11963c912837d0d35b">mat_print</a> (const <a class="el" href="linalg_8h.html#abc75382643898dd572498a574bf891c7">matrix</a> *mat)</td></tr>
<tr class="memdesc:a3c4e05af95e01c11963c912837d0d35b"><td class="mdescLeft">&#160;</td><td class="mdescRight">prints the matrix this function will not modify the matrix and print to stdout  <a href="#a3c4e05af95e01c11963c912837d0d35b">More...</a><br/></td></tr>
<tr class="separator:a3c4e05af95e01c11963c912837d0d35b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d2e72678bf82c44ba57020fc8588868"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linalg_8h.html#a1d2e72678bf82c44ba57020fc8588868">vec_print</a> (const <a class="el" href="linalg_8h.html#a07a01529159cc35e78c1f7731ac7bda6">vector</a> *vec)</td></tr>
<tr class="memdesc:a1d2e72678bf82c44ba57020fc8588868"><td class="mdescLeft">&#160;</td><td class="mdescRight">prints the vector this function will not modify the vector and print to stdout  <a href="#a1d2e72678bf82c44ba57020fc8588868">More...</a><br/></td></tr>
<tr class="separator:a1d2e72678bf82c44ba57020fc8588868"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40a3d6442169157a458362f5e85c5843"><td class="memItemLeft" align="right" valign="top"><a class="el" href="linalg_8h.html#abc75382643898dd572498a574bf891c7">matrix</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linalg_8h.html#a40a3d6442169157a458362f5e85c5843">matmat_multiply</a> (const <a class="el" href="linalg_8h.html#abc75382643898dd572498a574bf891c7">matrix</a> *left, const <a class="el" href="linalg_8h.html#abc75382643898dd572498a574bf891c7">matrix</a> *right)</td></tr>
<tr class="memdesc:a40a3d6442169157a458362f5e85c5843"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs standard matrix multiplication this function will malloc for the user a matrix*.  <a href="#a40a3d6442169157a458362f5e85c5843">More...</a><br/></td></tr>
<tr class="separator:a40a3d6442169157a458362f5e85c5843"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d1ca6441796b3d9c53f2a2923dc06c7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="linalg_8h.html#abc75382643898dd572498a574bf891c7">matrix</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linalg_8h.html#a9d1ca6441796b3d9c53f2a2923dc06c7">matmat_addition</a> (const <a class="el" href="linalg_8h.html#abc75382643898dd572498a574bf891c7">matrix</a> *left, const <a class="el" href="linalg_8h.html#abc75382643898dd572498a574bf891c7">matrix</a> *right)</td></tr>
<tr class="memdesc:a9d1ca6441796b3d9c53f2a2923dc06c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs standard matrix addition this function will malloc for the user a matrix*.  <a href="#a9d1ca6441796b3d9c53f2a2923dc06c7">More...</a><br/></td></tr>
<tr class="separator:a9d1ca6441796b3d9c53f2a2923dc06c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b7138d5fae752feceeb9faea996cb54"><td class="memItemLeft" align="right" valign="top"><a class="el" href="linalg_8h.html#abc75382643898dd572498a574bf891c7">matrix</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linalg_8h.html#a6b7138d5fae752feceeb9faea996cb54">matmat_subtraction</a> (const <a class="el" href="linalg_8h.html#abc75382643898dd572498a574bf891c7">matrix</a> *left, const <a class="el" href="linalg_8h.html#abc75382643898dd572498a574bf891c7">matrix</a> *right)</td></tr>
<tr class="memdesc:a6b7138d5fae752feceeb9faea996cb54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs standard matrix subtration this function will malloc for the user a matrix*.  <a href="#a6b7138d5fae752feceeb9faea996cb54">More...</a><br/></td></tr>
<tr class="separator:a6b7138d5fae752feceeb9faea996cb54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32cb81b161008e2b1fd862ae9d45caa2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="linalg_8h.html#abc75382643898dd572498a574bf891c7">matrix</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linalg_8h.html#a32cb81b161008e2b1fd862ae9d45caa2">matscalar_multiply</a> (const <a class="el" href="linalg_8h.html#abc75382643898dd572498a574bf891c7">matrix</a> *mat, const double scalar)</td></tr>
<tr class="memdesc:a32cb81b161008e2b1fd862ae9d45caa2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs scalar multiplication of a matrix this function will malloc for the user a matrix*.  <a href="#a32cb81b161008e2b1fd862ae9d45caa2">More...</a><br/></td></tr>
<tr class="separator:a32cb81b161008e2b1fd862ae9d45caa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98269f4c3f77b32dc52e30108713cb28"><td class="memItemLeft" align="right" valign="top"><a class="el" href="linalg_8h.html#abc75382643898dd572498a574bf891c7">matrix</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linalg_8h.html#a98269f4c3f77b32dc52e30108713cb28">matscalar_divide</a> (const <a class="el" href="linalg_8h.html#abc75382643898dd572498a574bf891c7">matrix</a> *mat, const double scalar)</td></tr>
<tr class="memdesc:a98269f4c3f77b32dc52e30108713cb28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs scalar division of a matrix this function will malloc for the user a matrix*.  <a href="#a98269f4c3f77b32dc52e30108713cb28">More...</a><br/></td></tr>
<tr class="separator:a98269f4c3f77b32dc52e30108713cb28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ac4400497d3a421f3f631d6329010b6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="linalg_8h.html#abc75382643898dd572498a574bf891c7">matrix</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linalg_8h.html#a2ac4400497d3a421f3f631d6329010b6">mat_transpose</a> (const <a class="el" href="linalg_8h.html#abc75382643898dd572498a574bf891c7">matrix</a> *mat)</td></tr>
<tr class="memdesc:a2ac4400497d3a421f3f631d6329010b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs matrix transpose this function will malloc for the user a matrix*.  <a href="#a2ac4400497d3a421f3f631d6329010b6">More...</a><br/></td></tr>
<tr class="separator:a2ac4400497d3a421f3f631d6329010b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbfad21fe7e851455d625173e67b8504"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linalg_8h.html#adbfad21fe7e851455d625173e67b8504">vec_append</a> (<a class="el" href="linalg_8h.html#a07a01529159cc35e78c1f7731ac7bda6">vector</a> **vec_a, <a class="el" href="linalg_8h.html#a07a01529159cc35e78c1f7731ac7bda6">vector</a> *vec_b)</td></tr>
<tr class="memdesc:adbfad21fe7e851455d625173e67b8504"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends vector b to vector a this function will realloc for the user vector a and free vector b.  <a href="#adbfad21fe7e851455d625173e67b8504">More...</a><br/></td></tr>
<tr class="separator:adbfad21fe7e851455d625173e67b8504"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2488d3254a915ffec423a4355b6a32a3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linalg_8h.html#a2488d3254a915ffec423a4355b6a32a3">eigen</a> (int N, double a[], int it_max, double v[], double d[], int *it_num, int *rot_num)</td></tr>
<tr class="memdesc:a2488d3254a915ffec423a4355b6a32a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs Jacobi eigenvalue iteration this function will required the user to pass in non-null it_num and rot_num it does not malloc but rather requires the caller to malloc space for it.  <a href="#a2488d3254a915ffec423a4355b6a32a3">More...</a><br/></td></tr>
<tr class="separator:a2488d3254a915ffec423a4355b6a32a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97f97bfa6f100928e8d6c9f085bd9d12"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linalg_8h.html#a97f97bfa6f100928e8d6c9f085bd9d12">mat_identity</a> (int n, double a[])</td></tr>
<tr class="memdesc:a97f97bfa6f100928e8d6c9f085bd9d12"><td class="mdescLeft">&#160;</td><td class="mdescRight">modifies a matrix to be the identity matrix of size n  <a href="#a97f97bfa6f100928e8d6c9f085bd9d12">More...</a><br/></td></tr>
<tr class="separator:a97f97bfa6f100928e8d6c9f085bd9d12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc4918a0c6b295404ebfadfe78b26bdd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linalg_8h.html#abc4918a0c6b295404ebfadfe78b26bdd">diag_vector</a> (int n, double a[], double v[])</td></tr>
<tr class="memdesc:abc4918a0c6b295404ebfadfe78b26bdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">gets the diagonal entries  <a href="#abc4918a0c6b295404ebfadfe78b26bdd">More...</a><br/></td></tr>
<tr class="separator:abc4918a0c6b295404ebfadfe78b26bdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a948f2b3da29647be0bcb62e717dfec2d"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linalg_8h.html#a948f2b3da29647be0bcb62e717dfec2d">frobenius_norm</a> (int n, int k, double a[], double x[], double lambda[])</td></tr>
<tr class="memdesc:a948f2b3da29647be0bcb62e717dfec2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">computes the Frobenius norm in a right eigensystem  <a href="#a948f2b3da29647be0bcb62e717dfec2d">More...</a><br/></td></tr>
<tr class="separator:a948f2b3da29647be0bcb62e717dfec2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad41ec0281d3766f40963b77520ce600d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="linalg_8h.html#abc75382643898dd572498a574bf891c7">matrix</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linalg_8h.html#ad41ec0281d3766f40963b77520ce600d">covmat</a> (<a class="el" href="linalg_8h.html#abc75382643898dd572498a574bf891c7">matrix</a> *mat)</td></tr>
<tr class="memdesc:ad41ec0281d3766f40963b77520ce600d"><td class="mdescLeft">&#160;</td><td class="mdescRight">computes the variance covariance matrix  <a href="#ad41ec0281d3766f40963b77520ce600d">More...</a><br/></td></tr>
<tr class="separator:ad41ec0281d3766f40963b77520ce600d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71f490da601d057f4ce45efb9a48c2ae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="linalg_8h.html#a07a01529159cc35e78c1f7731ac7bda6">vector</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linalg_8h.html#a71f490da601d057f4ce45efb9a48c2ae">compute_average</a> (<a class="el" href="linalg_8h.html#abc75382643898dd572498a574bf891c7">matrix</a> *images, int num_images)</td></tr>
<tr class="memdesc:a71f490da601d057f4ce45efb9a48c2ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">computes the average matrix of all the *vector images  <a href="#a71f490da601d057f4ce45efb9a48c2ae">More...</a><br/></td></tr>
<tr class="separator:a71f490da601d057f4ce45efb9a48c2ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>File containing common linear algebra functions. </p>
<p>Minhyuk Park </p>
<dl class="section date"><dt>Date</dt><dd>7 Nov 2017 </dd></dl>
</div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a71f490da601d057f4ce45efb9a48c2ae"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="linalg_8h.html#a07a01529159cc35e78c1f7731ac7bda6">vector</a>* compute_average </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="linalg_8h.html#abc75382643898dd572498a574bf891c7">matrix</a> *&#160;</td>
          <td class="paramname"><em>images</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_images</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>computes the average matrix of all the *vector images </p>
<dl class="section return"><dt>Returns</dt><dd>vector* the average image </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">images</td><td>matrix* a matrix where each column represents an image </td></tr>
    <tr><td class="paramname">num_images</td><td>int number of images in the vector </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="linalg_8h.html#ae0e32e641b8137c777d52988864296e3">MAT</a>, <a class="el" href="struct__matrix.html#a1087bec6a11b0773b4852c4ca49fc32a">_matrix::row</a>, <a class="el" href="struct__vector.html#a1ed8dca78f3e589deb8dad9b53aec3fa">_vector::size</a>, <a class="el" href="linalg_8h.html#a03e904294c904b01194a25323fc2f6ec">VEC</a>, and <a class="el" href="linalg_8c.html#a7040be230e99648e77b0932600bf55ef">vector_create()</a>.</p>
<div class="fragment"><div class="line"><a name="l00407"></a><span class="lineno">  407</span>&#160;                                                        {</div>
<div class="line"><a name="l00408"></a><span class="lineno">  408</span>&#160;    <span class="comment">/*</span></div>
<div class="line"><a name="l00409"></a><span class="lineno">  409</span>&#160;<span class="comment">    matrix* ones_row = matrix_create(1, num_images);</span></div>
<div class="line"><a name="l00410"></a><span class="lineno">  410</span>&#160;<span class="comment">    for(int i =0; i &lt;num_images; i++) {</span></div>
<div class="line"><a name="l00411"></a><span class="lineno">  411</span>&#160;<span class="comment">        MAT(ones_row, 0,i) = 1;</span></div>
<div class="line"><a name="l00412"></a><span class="lineno">  412</span>&#160;<span class="comment">    }</span></div>
<div class="line"><a name="l00413"></a><span class="lineno">  413</span>&#160;<span class="comment">    matrix* row_images = mat_transpose(images);</span></div>
<div class="line"><a name="l00414"></a><span class="lineno">  414</span>&#160;<span class="comment">    matrix* row_sum = matmat_multiply(ones_row, row_images);</span></div>
<div class="line"><a name="l00415"></a><span class="lineno">  415</span>&#160;<span class="comment">    vector* vector_row_sum = mat_to_vec(row_sum);</span></div>
<div class="line"><a name="l00416"></a><span class="lineno">  416</span>&#160;<span class="comment">    vector* img_avg = vecscalar_divide(vector_row_sum, num_images);</span></div>
<div class="line"><a name="l00417"></a><span class="lineno">  417</span>&#160;<span class="comment">    free(vector_row_sum);</span></div>
<div class="line"><a name="l00418"></a><span class="lineno">  418</span>&#160;<span class="comment">    free(row_images);</span></div>
<div class="line"><a name="l00419"></a><span class="lineno">  419</span>&#160;<span class="comment">    free(ones_row);</span></div>
<div class="line"><a name="l00420"></a><span class="lineno">  420</span>&#160;<span class="comment">    */</span></div>
<div class="line"><a name="l00421"></a><span class="lineno">  421</span>&#160;    <a class="code" href="struct__vector.html">vector</a>* img_avg = <a class="code" href="linalg_8c.html#a7040be230e99648e77b0932600bf55ef">vector_create</a>(images-&gt;<a class="code" href="struct__matrix.html#a1087bec6a11b0773b4852c4ca49fc32a">row</a>);</div>
<div class="line"><a name="l00422"></a><span class="lineno">  422</span>&#160;</div>
<div class="line"><a name="l00423"></a><span class="lineno">  423</span>&#160;    <span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> i = 0; i &lt; img_avg-&gt;<a class="code" href="struct__vector.html#a1ed8dca78f3e589deb8dad9b53aec3fa">size</a>; i ++) {</div>
<div class="line"><a name="l00424"></a><span class="lineno">  424</span>&#160;        uint32 avg_pixel = 0;</div>
<div class="line"><a name="l00425"></a><span class="lineno">  425</span>&#160;</div>
<div class="line"><a name="l00426"></a><span class="lineno">  426</span>&#160;        uint32 r = 0;</div>
<div class="line"><a name="l00427"></a><span class="lineno">  427</span>&#160;        uint32 g = 0;</div>
<div class="line"><a name="l00428"></a><span class="lineno">  428</span>&#160;        uint32 b = 0;</div>
<div class="line"><a name="l00429"></a><span class="lineno">  429</span>&#160;        uint32 a = 0;</div>
<div class="line"><a name="l00430"></a><span class="lineno">  430</span>&#160;        <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j = 0; j &lt; num_images; j ++) {</div>
<div class="line"><a name="l00431"></a><span class="lineno">  431</span>&#160;            uint32 current_pixel = <a class="code" href="linalg_8h.html#ae0e32e641b8137c777d52988864296e3">MAT</a>(images, i, j);</div>
<div class="line"><a name="l00432"></a><span class="lineno">  432</span>&#160;</div>
<div class="line"><a name="l00433"></a><span class="lineno">  433</span>&#160;            r += ((current_pixel &amp; 0xff) * (current_pixel &amp; 0xff));</div>
<div class="line"><a name="l00434"></a><span class="lineno">  434</span>&#160;            g += (((current_pixel &gt;&gt; 8) &amp; 0xff) * ((current_pixel &gt;&gt; 8) &amp; 0xff));</div>
<div class="line"><a name="l00435"></a><span class="lineno">  435</span>&#160;            b += (((current_pixel &gt;&gt; 16) &amp; 0xff) * ((current_pixel &gt;&gt; 16) &amp; 0xff));</div>
<div class="line"><a name="l00436"></a><span class="lineno">  436</span>&#160;            a += (((current_pixel &gt;&gt; 24) &amp; 0xff) * ((current_pixel &gt;&gt; 24) &amp; 0xff));</div>
<div class="line"><a name="l00437"></a><span class="lineno">  437</span>&#160;        }</div>
<div class="line"><a name="l00438"></a><span class="lineno">  438</span>&#160;</div>
<div class="line"><a name="l00439"></a><span class="lineno">  439</span>&#160;        r /= num_images;</div>
<div class="line"><a name="l00440"></a><span class="lineno">  440</span>&#160;        g /= num_images;</div>
<div class="line"><a name="l00441"></a><span class="lineno">  441</span>&#160;        b /= num_images;</div>
<div class="line"><a name="l00442"></a><span class="lineno">  442</span>&#160;        a /= num_images;</div>
<div class="line"><a name="l00443"></a><span class="lineno">  443</span>&#160;</div>
<div class="line"><a name="l00444"></a><span class="lineno">  444</span>&#160;        r = sqrt(r);</div>
<div class="line"><a name="l00445"></a><span class="lineno">  445</span>&#160;        g = sqrt(g);</div>
<div class="line"><a name="l00446"></a><span class="lineno">  446</span>&#160;        b = sqrt(b);</div>
<div class="line"><a name="l00447"></a><span class="lineno">  447</span>&#160;        a = sqrt(a);</div>
<div class="line"><a name="l00448"></a><span class="lineno">  448</span>&#160;        <span class="comment">/*</span></div>
<div class="line"><a name="l00449"></a><span class="lineno">  449</span>&#160;<span class="comment">        for(int j = 0; j &lt; num_images; j ++) {</span></div>
<div class="line"><a name="l00450"></a><span class="lineno">  450</span>&#160;<span class="comment">            uint32 current_pixel = MAT(images, i, j);</span></div>
<div class="line"><a name="l00451"></a><span class="lineno">  451</span>&#160;<span class="comment"></span></div>
<div class="line"><a name="l00452"></a><span class="lineno">  452</span>&#160;<span class="comment">            r += ((current_pixel &amp; 0xff));</span></div>
<div class="line"><a name="l00453"></a><span class="lineno">  453</span>&#160;<span class="comment">            g += (((current_pixel &gt;&gt; 8) &amp; 0xff));</span></div>
<div class="line"><a name="l00454"></a><span class="lineno">  454</span>&#160;<span class="comment">            b += (((current_pixel &gt;&gt; 16) &amp; 0xff));</span></div>
<div class="line"><a name="l00455"></a><span class="lineno">  455</span>&#160;<span class="comment">            a += (((current_pixel &gt;&gt; 24) &amp; 0xff));</span></div>
<div class="line"><a name="l00456"></a><span class="lineno">  456</span>&#160;<span class="comment">        }</span></div>
<div class="line"><a name="l00457"></a><span class="lineno">  457</span>&#160;<span class="comment"></span></div>
<div class="line"><a name="l00458"></a><span class="lineno">  458</span>&#160;<span class="comment">        r /= num_images;</span></div>
<div class="line"><a name="l00459"></a><span class="lineno">  459</span>&#160;<span class="comment">        g /= num_images;</span></div>
<div class="line"><a name="l00460"></a><span class="lineno">  460</span>&#160;<span class="comment">        b /= num_images;</span></div>
<div class="line"><a name="l00461"></a><span class="lineno">  461</span>&#160;<span class="comment">        a /= num_images;</span></div>
<div class="line"><a name="l00462"></a><span class="lineno">  462</span>&#160;<span class="comment">        */</span></div>
<div class="line"><a name="l00463"></a><span class="lineno">  463</span>&#160;</div>
<div class="line"><a name="l00464"></a><span class="lineno">  464</span>&#160;</div>
<div class="line"><a name="l00465"></a><span class="lineno">  465</span>&#160;        avg_pixel |= r;</div>
<div class="line"><a name="l00466"></a><span class="lineno">  466</span>&#160;        avg_pixel |= (g &lt;&lt; 8);</div>
<div class="line"><a name="l00467"></a><span class="lineno">  467</span>&#160;        avg_pixel |= (b &lt;&lt; 16);</div>
<div class="line"><a name="l00468"></a><span class="lineno">  468</span>&#160;        avg_pixel |= (a &lt;&lt; 24);</div>
<div class="line"><a name="l00469"></a><span class="lineno">  469</span>&#160;</div>
<div class="line"><a name="l00470"></a><span class="lineno">  470</span>&#160;        <a class="code" href="linalg_8h.html#a03e904294c904b01194a25323fc2f6ec">VEC</a>(img_avg, i) = avg_pixel;</div>
<div class="line"><a name="l00471"></a><span class="lineno">  471</span>&#160;    }</div>
<div class="line"><a name="l00472"></a><span class="lineno">  472</span>&#160;</div>
<div class="line"><a name="l00473"></a><span class="lineno">  473</span>&#160;</div>
<div class="line"><a name="l00474"></a><span class="lineno">  474</span>&#160;    </div>
<div class="line"><a name="l00475"></a><span class="lineno">  475</span>&#160;</div>
<div class="line"><a name="l00476"></a><span class="lineno">  476</span>&#160;    <span class="keywordflow">return</span> img_avg;</div>
<div class="line"><a name="l00477"></a><span class="lineno">  477</span>&#160;}</div>
<div class="ttc" id="linalg_8c_html_a7040be230e99648e77b0932600bf55ef"><div class="ttname"><a href="linalg_8c.html#a7040be230e99648e77b0932600bf55ef">vector_create</a></div><div class="ttdeci">vector * vector_create(size_t size)</div><div class="ttdoc">Creates a vector this function will malloc the exact space for the required dimensions. </div><div class="ttdef"><b>Definition:</b> linalg.c:11</div></div>
<div class="ttc" id="linalg_8h_html_a03e904294c904b01194a25323fc2f6ec"><div class="ttname"><a href="linalg_8h.html#a03e904294c904b01194a25323fc2f6ec">VEC</a></div><div class="ttdeci">#define VEC(v, x)</div><div class="ttdoc">macro for element access in a vector struct </div><div class="ttdef"><b>Definition:</b> linalg.h:19</div></div>
<div class="ttc" id="struct__matrix_html_a1087bec6a11b0773b4852c4ca49fc32a"><div class="ttname"><a href="struct__matrix.html#a1087bec6a11b0773b4852c4ca49fc32a">_matrix::row</a></div><div class="ttdeci">size_t row</div><div class="ttdoc">the number of rows in the matrix </div><div class="ttdef"><b>Definition:</b> linalg.h:42</div></div>
<div class="ttc" id="struct__vector_html_a1ed8dca78f3e589deb8dad9b53aec3fa"><div class="ttname"><a href="struct__vector.html#a1ed8dca78f3e589deb8dad9b53aec3fa">_vector::size</a></div><div class="ttdeci">size_t size</div><div class="ttdoc">the number of elements in the vector </div><div class="ttdef"><b>Definition:</b> linalg.h:29</div></div>
<div class="ttc" id="linalg_8h_html_ae0e32e641b8137c777d52988864296e3"><div class="ttname"><a href="linalg_8h.html#ae0e32e641b8137c777d52988864296e3">MAT</a></div><div class="ttdeci">#define MAT(m, x, y)</div><div class="ttdoc">macro for element access in a matrix struct </div><div class="ttdef"><b>Definition:</b> linalg.h:17</div></div>
<div class="ttc" id="struct__vector_html"><div class="ttname"><a href="struct__vector.html">_vector</a></div><div class="ttdoc">represents a vector padding is to make sure that matrix and vector both have the same byte size and a...</div><div class="ttdef"><b>Definition:</b> linalg.h:27</div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ad41ec0281d3766f40963b77520ce600d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="linalg_8h.html#abc75382643898dd572498a574bf891c7">matrix</a>* covmat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="linalg_8h.html#abc75382643898dd572498a574bf891c7">matrix</a> *&#160;</td>
          <td class="paramname"><em>mat</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>computes the variance covariance matrix </p>
<dl class="section return"><dt>Returns</dt><dd>matrix* the output variance-covariance matrix this function will malloc a new matrix </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>a matrix* representing the input matrix of deviation scores of size n by k </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="linalg_8c.html#a2ac4400497d3a421f3f631d6329010b6">mat_transpose()</a>, <a class="el" href="linalg_8c.html#a40a3d6442169157a458362f5e85c5843">matmat_multiply()</a>, <a class="el" href="linalg_8c.html#a98269f4c3f77b32dc52e30108713cb28">matscalar_divide()</a>, and <a class="el" href="struct__matrix.html#a1087bec6a11b0773b4852c4ca49fc32a">_matrix::row</a>.</p>
<div class="fragment"><div class="line"><a name="l00397"></a><span class="lineno">  397</span>&#160;                            {</div>
<div class="line"><a name="l00398"></a><span class="lineno">  398</span>&#160;    <span class="keywordtype">size_t</span> n = mat-&gt;<a class="code" href="struct__matrix.html#a1087bec6a11b0773b4852c4ca49fc32a">row</a>;</div>
<div class="line"><a name="l00399"></a><span class="lineno">  399</span>&#160;    <a class="code" href="struct__matrix.html">matrix</a>* mat_T = <a class="code" href="linalg_8c.html#a2ac4400497d3a421f3f631d6329010b6">mat_transpose</a>(mat);</div>
<div class="line"><a name="l00400"></a><span class="lineno">  400</span>&#160;    <a class="code" href="struct__matrix.html">matrix</a>* x_T_x = <a class="code" href="linalg_8c.html#a40a3d6442169157a458362f5e85c5843">matmat_multiply</a>(mat_T, mat);</div>
<div class="line"><a name="l00401"></a><span class="lineno">  401</span>&#160;    <a class="code" href="struct__matrix.html">matrix</a>* retmat = <a class="code" href="linalg_8c.html#a98269f4c3f77b32dc52e30108713cb28">matscalar_divide</a>(x_T_x, n);</div>
<div class="line"><a name="l00402"></a><span class="lineno">  402</span>&#160;    free(x_T_x);</div>
<div class="line"><a name="l00403"></a><span class="lineno">  403</span>&#160;    free(mat_T);</div>
<div class="line"><a name="l00404"></a><span class="lineno">  404</span>&#160;    <span class="keywordflow">return</span> retmat;</div>
<div class="line"><a name="l00405"></a><span class="lineno">  405</span>&#160;}</div>
<div class="ttc" id="struct__matrix_html"><div class="ttname"><a href="struct__matrix.html">_matrix</a></div><div class="ttdoc">represents a matrix between matrix and vector they are able to be casted into one another ...</div><div class="ttdef"><b>Definition:</b> linalg.h:40</div></div>
<div class="ttc" id="linalg_8c_html_a2ac4400497d3a421f3f631d6329010b6"><div class="ttname"><a href="linalg_8c.html#a2ac4400497d3a421f3f631d6329010b6">mat_transpose</a></div><div class="ttdeci">matrix * mat_transpose(const matrix *mat)</div><div class="ttdoc">Performs matrix transpose this function will malloc for the user a matrix*. </div><div class="ttdef"><b>Definition:</b> linalg.c:181</div></div>
<div class="ttc" id="struct__matrix_html_a1087bec6a11b0773b4852c4ca49fc32a"><div class="ttname"><a href="struct__matrix.html#a1087bec6a11b0773b4852c4ca49fc32a">_matrix::row</a></div><div class="ttdeci">size_t row</div><div class="ttdoc">the number of rows in the matrix </div><div class="ttdef"><b>Definition:</b> linalg.h:42</div></div>
<div class="ttc" id="linalg_8c_html_a40a3d6442169157a458362f5e85c5843"><div class="ttname"><a href="linalg_8c.html#a40a3d6442169157a458362f5e85c5843">matmat_multiply</a></div><div class="ttdeci">matrix * matmat_multiply(const matrix *left, const matrix *right)</div><div class="ttdoc">Performs standard matrix multiplication this function will malloc for the user a matrix*. </div><div class="ttdef"><b>Definition:</b> linalg.c:129</div></div>
<div class="ttc" id="linalg_8c_html_a98269f4c3f77b32dc52e30108713cb28"><div class="ttname"><a href="linalg_8c.html#a98269f4c3f77b32dc52e30108713cb28">matscalar_divide</a></div><div class="ttdeci">matrix * matscalar_divide(const matrix *mat, const double scalar)</div><div class="ttdoc">Performs scalar division of a matrix this function will malloc for the user a matrix*. </div><div class="ttdef"><b>Definition:</b> linalg.c:176</div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="abc4918a0c6b295404ebfadfe78b26bdd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void diag_vector </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>v</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>gets the diagonal entries </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>int the dimension </td></tr>
    <tr><td class="paramname">a[]</td><td>double[] input the matrix, N by N </td></tr>
    <tr><td class="paramname">v[]</td><td>double[] output the diagonal entries, N </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="linalg_8h.html#a2488d3254a915ffec423a4355b6a32a3">eigen()</a>.</p>
<div class="fragment"><div class="line"><a name="l00363"></a><span class="lineno">  363</span>&#160;                                                {</div>
<div class="line"><a name="l00364"></a><span class="lineno">  364</span>&#160;    <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; n; i ++) {</div>
<div class="line"><a name="l00365"></a><span class="lineno">  365</span>&#160;        v[i] = a[i + i * n];</div>
<div class="line"><a name="l00366"></a><span class="lineno">  366</span>&#160;    }</div>
<div class="line"><a name="l00367"></a><span class="lineno">  367</span>&#160;    <span class="keywordflow">return</span>;</div>
<div class="line"><a name="l00368"></a><span class="lineno">  368</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="afc298e7d7d6a208e71ef073948b651d2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double dot_product </td>
          <td>(</td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs dot product on two double* this function will malloc for the user a double arrays must be of same size. </p>
<dl class="section return"><dt>Returns</dt><dd>a double representing the inner product </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">left</td><td>const double* the first vector </td></tr>
    <tr><td class="paramname">right</td><td>const double* the second vector </td></tr>
    <tr><td class="paramname">length</td><td>int the size of the vectors </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="linalg_8h.html#af88415d8996030537851e2c48d5337c4">matvec_multiply()</a>.</p>
<div class="fragment"><div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;                                                                        {</div>
<div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;    <span class="keywordtype">double</span> retval = 0.0;</div>
<div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;    <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; length; i ++) {</div>
<div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;        retval += (left[i] * right[i]);</div>
<div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;    }</div>
<div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;    <span class="keywordflow">return</span> retval;</div>
<div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a2488d3254a915ffec423a4355b6a32a3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void eigen </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>it_max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>v</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>d</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>it_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>rot_num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs Jacobi eigenvalue iteration this function will required the user to pass in non-null it_num and rot_num it does not malloc but rather requires the caller to malloc space for it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">N</td><td>int the dimiension of the input matrix a, which is a N by N matrix </td></tr>
    <tr><td class="paramname">a[]</td><td>double[] the input matrix which has to be square, real, and symmetric </td></tr>
    <tr><td class="paramname">it_max</td><td>int maximum number of iterations to stop at </td></tr>
    <tr><td class="paramname">v[]</td><td>double[]output matrix of eigenvectors, which is a N by N matrix </td></tr>
    <tr><td class="paramname">d[]</td><td>double[] output matrix of eigenvalues, in descending order </td></tr>
    <tr><td class="paramname">it_num</td><td>int* output total number of iterations </td></tr>
    <tr><td class="paramname">rot_num</td><td>int* output total number of rotations </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="linalg_8c.html#abc4918a0c6b295404ebfadfe78b26bdd">diag_vector()</a>, and <a class="el" href="linalg_8c.html#a97f97bfa6f100928e8d6c9f085bd9d12">mat_identity()</a>.</p>
<div class="fragment"><div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160;                                                                                             {</div>
<div class="line"><a name="l00213"></a><span class="lineno">  213</span>&#160;    <a class="code" href="linalg_8c.html#a97f97bfa6f100928e8d6c9f085bd9d12">mat_identity</a>(n, v); <span class="comment">// create the identity matrix using what the caller allocated for us</span></div>
<div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160;    <a class="code" href="linalg_8c.html#abc4918a0c6b295404ebfadfe78b26bdd">diag_vector</a>(n, a, d); <span class="comment">// get the diagonal values of a and store it in caller allocated vector d</span></div>
<div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160;</div>
<div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160;    <span class="keywordtype">double</span>* bw = (<span class="keywordtype">double</span>*) malloc(n * <span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));</div>
<div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160;    <span class="keywordtype">double</span>* zw = (<span class="keywordtype">double</span>*) malloc(n * <span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));</div>
<div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;</div>
<div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;    <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; n; i ++) {</div>
<div class="line"><a name="l00220"></a><span class="lineno">  220</span>&#160;        bw[i] = d[i];</div>
<div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160;        zw[i] = 0.0;</div>
<div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;    }</div>
<div class="line"><a name="l00223"></a><span class="lineno">  223</span>&#160;    *it_num = 0;</div>
<div class="line"><a name="l00224"></a><span class="lineno">  224</span>&#160;    *rot_num = 0;</div>
<div class="line"><a name="l00225"></a><span class="lineno">  225</span>&#160;</div>
<div class="line"><a name="l00226"></a><span class="lineno">  226</span>&#160;    <span class="keywordtype">double</span> thresh = 0.0;</div>
<div class="line"><a name="l00227"></a><span class="lineno">  227</span>&#160;    <span class="keywordtype">double</span> gapq = 0.0;</div>
<div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160;    <span class="keywordflow">while</span>(*it_num &lt; it_max) {</div>
<div class="line"><a name="l00229"></a><span class="lineno">  229</span>&#160;        *it_num += 1;</div>
<div class="line"><a name="l00230"></a><span class="lineno">  230</span>&#160;        thresh = 0.0;</div>
<div class="line"><a name="l00231"></a><span class="lineno">  231</span>&#160;        <span class="comment">// set up the convergence threshold</span></div>
<div class="line"><a name="l00232"></a><span class="lineno">  232</span>&#160;        <span class="comment">// based on the size of strict upper triangle</span></div>
<div class="line"><a name="l00233"></a><span class="lineno">  233</span>&#160;        <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; n; i ++) {</div>
<div class="line"><a name="l00234"></a><span class="lineno">  234</span>&#160;            <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j = 0; j &lt; i; j ++) {</div>
<div class="line"><a name="l00235"></a><span class="lineno">  235</span>&#160;                thresh += (a[j + i * n] * a[j + i * n]);</div>
<div class="line"><a name="l00236"></a><span class="lineno">  236</span>&#160;            }</div>
<div class="line"><a name="l00237"></a><span class="lineno">  237</span>&#160;        }</div>
<div class="line"><a name="l00238"></a><span class="lineno">  238</span>&#160;        <span class="comment">// PASS 1</span></div>
<div class="line"><a name="l00239"></a><span class="lineno">  239</span>&#160;        thresh = sqrt(thresh) / (double)(4 * n);</div>
<div class="line"><a name="l00240"></a><span class="lineno">  240</span>&#160;        <span class="keywordflow">if</span>(thresh == 0.0) {</div>
<div class="line"><a name="l00241"></a><span class="lineno">  241</span>&#160;            <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l00242"></a><span class="lineno">  242</span>&#160;        }</div>
<div class="line"><a name="l00243"></a><span class="lineno">  243</span>&#160;        <span class="comment">// PASS 2</span></div>
<div class="line"><a name="l00244"></a><span class="lineno">  244</span>&#160;        <span class="keywordflow">for</span>(<span class="keywordtype">int</span> p = 0; p &lt; n; p ++) {</div>
<div class="line"><a name="l00245"></a><span class="lineno">  245</span>&#160;            <span class="keywordflow">for</span>(<span class="keywordtype">int</span> q = p + 1; q &lt; n; q ++) {</div>
<div class="line"><a name="l00246"></a><span class="lineno">  246</span>&#160;                gapq = 10.0 * fabs(a[p + q * n]);</div>
<div class="line"><a name="l00247"></a><span class="lineno">  247</span>&#160;                <span class="keywordtype">double</span> termp = gapq + fabs(d[p]);</div>
<div class="line"><a name="l00248"></a><span class="lineno">  248</span>&#160;                <span class="keywordtype">double</span> termq = gapq + fabs(d[q]);</div>
<div class="line"><a name="l00249"></a><span class="lineno">  249</span>&#160;                <span class="keywordflow">if</span>(4 &lt; *it_num &amp;&amp; termp == fabs(d[p]) &amp;&amp; termq == fabs(d[q])) {</div>
<div class="line"><a name="l00250"></a><span class="lineno">  250</span>&#160;                    a[p + q * n] = 0.0;</div>
<div class="line"><a name="l00251"></a><span class="lineno">  251</span>&#160;                <span class="comment">// apply rotation otherwise</span></div>
<div class="line"><a name="l00252"></a><span class="lineno">  252</span>&#160;                <span class="comment">// PASS 3</span></div>
<div class="line"><a name="l00253"></a><span class="lineno">  253</span>&#160;                } <span class="keywordflow">else</span> <span class="keywordflow">if</span>(thresh &lt;= fabs(a[p + q * n])) {</div>
<div class="line"><a name="l00254"></a><span class="lineno">  254</span>&#160;                    <span class="keywordtype">double</span> h = d[q] - d[p];</div>
<div class="line"><a name="l00255"></a><span class="lineno">  255</span>&#160;                    <span class="keywordtype">double</span> term = fabs(h) + gapq;</div>
<div class="line"><a name="l00256"></a><span class="lineno">  256</span>&#160;                    <span class="keywordtype">double</span> t = 0.0;</div>
<div class="line"><a name="l00257"></a><span class="lineno">  257</span>&#160;                    <span class="keywordflow">if</span>(term == fabs(h)) {</div>
<div class="line"><a name="l00258"></a><span class="lineno">  258</span>&#160;                        t = a[p + q * n] / h;</div>
<div class="line"><a name="l00259"></a><span class="lineno">  259</span>&#160;                    } <span class="keywordflow">else</span> {</div>
<div class="line"><a name="l00260"></a><span class="lineno">  260</span>&#160;                        <span class="keywordtype">double</span> theta = 0.5 * h / a[p + q * n];</div>
<div class="line"><a name="l00261"></a><span class="lineno">  261</span>&#160;                        t = 1.0 / (fabs(theta) + sqrt(1.0 + theta * theta));</div>
<div class="line"><a name="l00262"></a><span class="lineno">  262</span>&#160;                        <span class="keywordflow">if</span>(theta &lt; 0.0) {</div>
<div class="line"><a name="l00263"></a><span class="lineno">  263</span>&#160;                            t = -t;</div>
<div class="line"><a name="l00264"></a><span class="lineno">  264</span>&#160;                        }</div>
<div class="line"><a name="l00265"></a><span class="lineno">  265</span>&#160;                    }</div>
<div class="line"><a name="l00266"></a><span class="lineno">  266</span>&#160;                    <span class="comment">// PASS 4</span></div>
<div class="line"><a name="l00267"></a><span class="lineno">  267</span>&#160;                    <span class="keywordtype">double</span> c = 1.0 / sqrt(1.0 + t * t);</div>
<div class="line"><a name="l00268"></a><span class="lineno">  268</span>&#160;                    <span class="keywordtype">double</span> s = t * c;</div>
<div class="line"><a name="l00269"></a><span class="lineno">  269</span>&#160;                    <span class="keywordtype">double</span> tau = s / (1.0 + c);</div>
<div class="line"><a name="l00270"></a><span class="lineno">  270</span>&#160;                    h = t * a[p + q * n];</div>
<div class="line"><a name="l00271"></a><span class="lineno">  271</span>&#160;</div>
<div class="line"><a name="l00272"></a><span class="lineno">  272</span>&#160;                    zw[p] -= h;</div>
<div class="line"><a name="l00273"></a><span class="lineno">  273</span>&#160;                    zw[q] += h;</div>
<div class="line"><a name="l00274"></a><span class="lineno">  274</span>&#160;                    d[p] -= h;</div>
<div class="line"><a name="l00275"></a><span class="lineno">  275</span>&#160;                    d[q] += h;</div>
<div class="line"><a name="l00276"></a><span class="lineno">  276</span>&#160;                    a[p + q * n] = 0.0;</div>
<div class="line"><a name="l00277"></a><span class="lineno">  277</span>&#160;                    <span class="comment">// PASS 5</span></div>
<div class="line"><a name="l00278"></a><span class="lineno">  278</span>&#160;                    <span class="comment">// rotate</span></div>
<div class="line"><a name="l00279"></a><span class="lineno">  279</span>&#160;                    <span class="keywordtype">double</span> g = 0.0;</div>
<div class="line"><a name="l00280"></a><span class="lineno">  280</span>&#160;                    <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j = 0; j &lt; p; j ++) {</div>
<div class="line"><a name="l00281"></a><span class="lineno">  281</span>&#160;                        g = a[j + p * n];</div>
<div class="line"><a name="l00282"></a><span class="lineno">  282</span>&#160;                        h = a[j + q * n];</div>
<div class="line"><a name="l00283"></a><span class="lineno">  283</span>&#160;                        a[j + p * n] = g - s * (h + g * tau);</div>
<div class="line"><a name="l00284"></a><span class="lineno">  284</span>&#160;                        a[j + q * n] = h + s * (g - h * tau);</div>
<div class="line"><a name="l00285"></a><span class="lineno">  285</span>&#160;                    }</div>
<div class="line"><a name="l00286"></a><span class="lineno">  286</span>&#160;                    <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j = p + 1; j &lt; q; j ++) {</div>
<div class="line"><a name="l00287"></a><span class="lineno">  287</span>&#160;                        g = a[p + j * n];</div>
<div class="line"><a name="l00288"></a><span class="lineno">  288</span>&#160;                        h = a[j + q * n];</div>
<div class="line"><a name="l00289"></a><span class="lineno">  289</span>&#160;                        a[p + j * n] = g - s * (h + g * tau);</div>
<div class="line"><a name="l00290"></a><span class="lineno">  290</span>&#160;                        a[j + q * n] = h + s * (g - h * tau);</div>
<div class="line"><a name="l00291"></a><span class="lineno">  291</span>&#160;                    }</div>
<div class="line"><a name="l00292"></a><span class="lineno">  292</span>&#160;                    <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j = q + 1; j &lt; n; j ++) {</div>
<div class="line"><a name="l00293"></a><span class="lineno">  293</span>&#160;                        g = a[p + j * n];</div>
<div class="line"><a name="l00294"></a><span class="lineno">  294</span>&#160;                        h = a[q + j * n];</div>
<div class="line"><a name="l00295"></a><span class="lineno">  295</span>&#160;                        a[p + j * n] = g - s * (h + g * tau);</div>
<div class="line"><a name="l00296"></a><span class="lineno">  296</span>&#160;                        a[q + j * n] = h + s * (g - h * tau);</div>
<div class="line"><a name="l00297"></a><span class="lineno">  297</span>&#160;                    }</div>
<div class="line"><a name="l00298"></a><span class="lineno">  298</span>&#160;                    <span class="comment">// PASS 6</span></div>
<div class="line"><a name="l00299"></a><span class="lineno">  299</span>&#160;                    <span class="comment">// store to eigenvector matrix v</span></div>
<div class="line"><a name="l00300"></a><span class="lineno">  300</span>&#160;                    <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j = 0; j &lt; n; j ++) {</div>
<div class="line"><a name="l00301"></a><span class="lineno">  301</span>&#160;                        g = v[j + p * n];</div>
<div class="line"><a name="l00302"></a><span class="lineno">  302</span>&#160;                        h = v[j + q * n];</div>
<div class="line"><a name="l00303"></a><span class="lineno">  303</span>&#160;                        v[j + p * n] = g - s * (h + g * tau);</div>
<div class="line"><a name="l00304"></a><span class="lineno">  304</span>&#160;                        v[j + q * n] = h + s * (g - h * tau);</div>
<div class="line"><a name="l00305"></a><span class="lineno">  305</span>&#160;                    }</div>
<div class="line"><a name="l00306"></a><span class="lineno">  306</span>&#160;                    *rot_num += 1;</div>
<div class="line"><a name="l00307"></a><span class="lineno">  307</span>&#160;                }</div>
<div class="line"><a name="l00308"></a><span class="lineno">  308</span>&#160;            }</div>
<div class="line"><a name="l00309"></a><span class="lineno">  309</span>&#160;        }</div>
<div class="line"><a name="l00310"></a><span class="lineno">  310</span>&#160;        <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; n; i ++) {</div>
<div class="line"><a name="l00311"></a><span class="lineno">  311</span>&#160;            bw[i] += zw[i];</div>
<div class="line"><a name="l00312"></a><span class="lineno">  312</span>&#160;            d[i] = bw[i];</div>
<div class="line"><a name="l00313"></a><span class="lineno">  313</span>&#160;            zw[i] = 0.0;</div>
<div class="line"><a name="l00314"></a><span class="lineno">  314</span>&#160;        }</div>
<div class="line"><a name="l00315"></a><span class="lineno">  315</span>&#160;    }</div>
<div class="line"><a name="l00316"></a><span class="lineno">  316</span>&#160;    <span class="comment">// PASS 7</span></div>
<div class="line"><a name="l00317"></a><span class="lineno">  317</span>&#160;    <span class="comment">// restore upper triangle</span></div>
<div class="line"><a name="l00318"></a><span class="lineno">  318</span>&#160;    <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; n; i ++) {</div>
<div class="line"><a name="l00319"></a><span class="lineno">  319</span>&#160;        <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j = 0; j &lt; i; j ++) {</div>
<div class="line"><a name="l00320"></a><span class="lineno">  320</span>&#160;            a[j + i * n] = a [i + j * n];</div>
<div class="line"><a name="l00321"></a><span class="lineno">  321</span>&#160;        }</div>
<div class="line"><a name="l00322"></a><span class="lineno">  322</span>&#160;    }</div>
<div class="line"><a name="l00323"></a><span class="lineno">  323</span>&#160;    <span class="keywordflow">for</span>(<span class="keywordtype">int</span> k = 0; k &lt; n - 1; k ++) {</div>
<div class="line"><a name="l00324"></a><span class="lineno">  324</span>&#160;        <span class="keywordtype">int</span> m = k;</div>
<div class="line"><a name="l00325"></a><span class="lineno">  325</span>&#160;        <span class="keywordflow">for</span>(<span class="keywordtype">int</span> l = k + 1; l &lt; n; l ++) {</div>
<div class="line"><a name="l00326"></a><span class="lineno">  326</span>&#160;            <span class="keywordflow">if</span>(d[l] &lt; d[m]) {</div>
<div class="line"><a name="l00327"></a><span class="lineno">  327</span>&#160;                m = l;</div>
<div class="line"><a name="l00328"></a><span class="lineno">  328</span>&#160;            }</div>
<div class="line"><a name="l00329"></a><span class="lineno">  329</span>&#160;        }</div>
<div class="line"><a name="l00330"></a><span class="lineno">  330</span>&#160;        <span class="keywordflow">if</span>(m != k) {</div>
<div class="line"><a name="l00331"></a><span class="lineno">  331</span>&#160;            <span class="keywordtype">double</span> t = d[m];</div>
<div class="line"><a name="l00332"></a><span class="lineno">  332</span>&#160;            d[m] = d[k];</div>
<div class="line"><a name="l00333"></a><span class="lineno">  333</span>&#160;            d[k] = t;</div>
<div class="line"><a name="l00334"></a><span class="lineno">  334</span>&#160;            <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; n; i ++) {</div>
<div class="line"><a name="l00335"></a><span class="lineno">  335</span>&#160;                <span class="keywordtype">double</span> w = v[i + m * n];</div>
<div class="line"><a name="l00336"></a><span class="lineno">  336</span>&#160;                v[i + m * n] = v[i + k * n];</div>
<div class="line"><a name="l00337"></a><span class="lineno">  337</span>&#160;                v[i + k * n] = w;</div>
<div class="line"><a name="l00338"></a><span class="lineno">  338</span>&#160;            }</div>
<div class="line"><a name="l00339"></a><span class="lineno">  339</span>&#160;        }</div>
<div class="line"><a name="l00340"></a><span class="lineno">  340</span>&#160;    }</div>
<div class="line"><a name="l00341"></a><span class="lineno">  341</span>&#160;    free(bw);</div>
<div class="line"><a name="l00342"></a><span class="lineno">  342</span>&#160;    free(zw);</div>
<div class="line"><a name="l00343"></a><span class="lineno">  343</span>&#160;    <span class="keywordflow">return</span>;</div>
<div class="line"><a name="l00344"></a><span class="lineno">  344</span>&#160;}</div>
<div class="ttc" id="linalg_8c_html_abc4918a0c6b295404ebfadfe78b26bdd"><div class="ttname"><a href="linalg_8c.html#abc4918a0c6b295404ebfadfe78b26bdd">diag_vector</a></div><div class="ttdeci">void diag_vector(int n, double a[], double v[])</div><div class="ttdoc">gets the diagonal entries </div><div class="ttdef"><b>Definition:</b> linalg.c:363</div></div>
<div class="ttc" id="linalg_8c_html_a97f97bfa6f100928e8d6c9f085bd9d12"><div class="ttname"><a href="linalg_8c.html#a97f97bfa6f100928e8d6c9f085bd9d12">mat_identity</a></div><div class="ttdeci">void mat_identity(int n, double a[])</div><div class="ttdoc">modifies a matrix to be the identity matrix of size n </div><div class="ttdef"><b>Definition:</b> linalg.c:347</div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a948f2b3da29647be0bcb62e717dfec2d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double frobenius_norm </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lambda</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>computes the Frobenius norm in a right eigensystem </p>
<dl class="section return"><dt>Returns</dt><dd>double the frobenius norm of A * X - X * lambda </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>int the dimension of the matrix </td></tr>
    <tr><td class="paramname">k</td><td>int the number of eigen vectors </td></tr>
    <tr><td class="paramname">a[]</td><td>double[] input matrix of size n by n </td></tr>
    <tr><td class="paramname">x[]</td><td>double[] input vector of eigenvectors of size k </td></tr>
    <tr><td class="paramname">lamdba[]</td><td>double[] input vector of eigen values </td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><a name="l00371"></a><span class="lineno">  371</span>&#160;                                                                             {</div>
<div class="line"><a name="l00372"></a><span class="lineno">  372</span>&#160;    <span class="keywordtype">double</span>* c = (<span class="keywordtype">double</span>*) malloc(n * k * <span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));</div>
<div class="line"><a name="l00373"></a><span class="lineno">  373</span>&#160;    <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; k; i ++) {</div>
<div class="line"><a name="l00374"></a><span class="lineno">  374</span>&#160;        <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j = 0; j &lt; n; j ++) {</div>
<div class="line"><a name="l00375"></a><span class="lineno">  375</span>&#160;            c[j + i * n] = 0.0;</div>
<div class="line"><a name="l00376"></a><span class="lineno">  376</span>&#160;            <span class="keywordflow">for</span>(<span class="keywordtype">int</span> l = 0; l &lt; n; l ++) {</div>
<div class="line"><a name="l00377"></a><span class="lineno">  377</span>&#160;                c[j + i * n] = c[j + i * n] + a[j + l * n] * x[l + i * n];</div>
<div class="line"><a name="l00378"></a><span class="lineno">  378</span>&#160;            }</div>
<div class="line"><a name="l00379"></a><span class="lineno">  379</span>&#160;        }</div>
<div class="line"><a name="l00380"></a><span class="lineno">  380</span>&#160;    }</div>
<div class="line"><a name="l00381"></a><span class="lineno">  381</span>&#160;    <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; k; i ++) {</div>
<div class="line"><a name="l00382"></a><span class="lineno">  382</span>&#160;        <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j = 0; j &lt; n; j ++) {</div>
<div class="line"><a name="l00383"></a><span class="lineno">  383</span>&#160;            c[j + i * n] = c[j + i * n] - lambda[i] * x[j + i * n];</div>
<div class="line"><a name="l00384"></a><span class="lineno">  384</span>&#160;        }</div>
<div class="line"><a name="l00385"></a><span class="lineno">  385</span>&#160;    }</div>
<div class="line"><a name="l00386"></a><span class="lineno">  386</span>&#160;    <span class="keywordtype">double</span> retval = 0.0;</div>
<div class="line"><a name="l00387"></a><span class="lineno">  387</span>&#160;    <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; k; i ++) {</div>
<div class="line"><a name="l00388"></a><span class="lineno">  388</span>&#160;        <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j = 0; j &lt; n; j ++) {</div>
<div class="line"><a name="l00389"></a><span class="lineno">  389</span>&#160;            retval += pow(c[j + i * n], 2);</div>
<div class="line"><a name="l00390"></a><span class="lineno">  390</span>&#160;        }</div>
<div class="line"><a name="l00391"></a><span class="lineno">  391</span>&#160;    }</div>
<div class="line"><a name="l00392"></a><span class="lineno">  392</span>&#160;    retval = sqrt(retval);</div>
<div class="line"><a name="l00393"></a><span class="lineno">  393</span>&#160;    free(c);</div>
<div class="line"><a name="l00394"></a><span class="lineno">  394</span>&#160;    <span class="keywordflow">return</span> retval;</div>
<div class="line"><a name="l00395"></a><span class="lineno">  395</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a97f97bfa6f100928e8d6c9f085bd9d12"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mat_identity </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>modifies a matrix to be the identity matrix of size n </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>int the dimension </td></tr>
    <tr><td class="paramname">a[]</td><td>double output identity matrix </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="linalg_8h.html#a2488d3254a915ffec423a4355b6a32a3">eigen()</a>.</p>
<div class="fragment"><div class="line"><a name="l00347"></a><span class="lineno">  347</span>&#160;                                     {</div>
<div class="line"><a name="l00348"></a><span class="lineno">  348</span>&#160;    <span class="keywordtype">int</span> k = 0;</div>
<div class="line"><a name="l00349"></a><span class="lineno">  349</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; n; j ++ ) {</div>
<div class="line"><a name="l00350"></a><span class="lineno">  350</span>&#160;        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; n; i ++ ) {</div>
<div class="line"><a name="l00351"></a><span class="lineno">  351</span>&#160;            <span class="keywordflow">if</span> ( i == j ) {</div>
<div class="line"><a name="l00352"></a><span class="lineno">  352</span>&#160;                a[k] = 1.0;</div>
<div class="line"><a name="l00353"></a><span class="lineno">  353</span>&#160;            } <span class="keywordflow">else</span> {</div>
<div class="line"><a name="l00354"></a><span class="lineno">  354</span>&#160;                a[k] = 0.0;</div>
<div class="line"><a name="l00355"></a><span class="lineno">  355</span>&#160;            }</div>
<div class="line"><a name="l00356"></a><span class="lineno">  356</span>&#160;            k += 1;</div>
<div class="line"><a name="l00357"></a><span class="lineno">  357</span>&#160;        }</div>
<div class="line"><a name="l00358"></a><span class="lineno">  358</span>&#160;    }</div>
<div class="line"><a name="l00359"></a><span class="lineno">  359</span>&#160;    <span class="keywordflow">return</span>;</div>
<div class="line"><a name="l00360"></a><span class="lineno">  360</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a3c4e05af95e01c11963c912837d0d35b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mat_print </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="linalg_8h.html#abc75382643898dd572498a574bf891c7">matrix</a> *&#160;</td>
          <td class="paramname"><em>mat</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>prints the matrix this function will not modify the matrix and print to stdout </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>const matrix* the matrix to be printed </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="struct__matrix.html#a7e9feb52cfc0a9d7cba5320abcaa997a">_matrix::col</a>, <a class="el" href="linalg_8h.html#ae0e32e641b8137c777d52988864296e3">MAT</a>, and <a class="el" href="struct__matrix.html#a1087bec6a11b0773b4852c4ca49fc32a">_matrix::row</a>.</p>
<div class="fragment"><div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;                                  {</div>
<div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;    <span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> i = 0; i &lt; mat-&gt;<a class="code" href="struct__matrix.html#a1087bec6a11b0773b4852c4ca49fc32a">row</a>; i ++) {</div>
<div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;        <span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> j = 0; j &lt; mat-&gt;<a class="code" href="struct__matrix.html#a7e9feb52cfc0a9d7cba5320abcaa997a">col</a>; j ++) {</div>
<div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;            <span class="keywordflow">if</span>(j == mat-&gt;<a class="code" href="struct__matrix.html#a7e9feb52cfc0a9d7cba5320abcaa997a">col</a> - 1) {</div>
<div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;                printf(<span class="stringliteral">&quot;%f &quot;</span>, <a class="code" href="linalg_8h.html#ae0e32e641b8137c777d52988864296e3">MAT</a>(mat, i, j));                </div>
<div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;            } <span class="keywordflow">else</span> {</div>
<div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;                printf(<span class="stringliteral">&quot;%f, &quot;</span>, <a class="code" href="linalg_8h.html#ae0e32e641b8137c777d52988864296e3">MAT</a>(mat, i, j));</div>
<div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;            }</div>
<div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;        }</div>
<div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;        printf(<span class="stringliteral">&quot;\n&quot;</span>);</div>
<div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;    }</div>
<div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;}</div>
<div class="ttc" id="struct__matrix_html_a1087bec6a11b0773b4852c4ca49fc32a"><div class="ttname"><a href="struct__matrix.html#a1087bec6a11b0773b4852c4ca49fc32a">_matrix::row</a></div><div class="ttdeci">size_t row</div><div class="ttdoc">the number of rows in the matrix </div><div class="ttdef"><b>Definition:</b> linalg.h:42</div></div>
<div class="ttc" id="struct__matrix_html_a7e9feb52cfc0a9d7cba5320abcaa997a"><div class="ttname"><a href="struct__matrix.html#a7e9feb52cfc0a9d7cba5320abcaa997a">_matrix::col</a></div><div class="ttdeci">size_t col</div><div class="ttdoc">the number of columns in the matrix </div><div class="ttdef"><b>Definition:</b> linalg.h:44</div></div>
<div class="ttc" id="linalg_8h_html_ae0e32e641b8137c777d52988864296e3"><div class="ttname"><a href="linalg_8h.html#ae0e32e641b8137c777d52988864296e3">MAT</a></div><div class="ttdeci">#define MAT(m, x, y)</div><div class="ttdoc">macro for element access in a matrix struct </div><div class="ttdef"><b>Definition:</b> linalg.h:17</div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a9059a420799b3aa9c04d5dd469523d91"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="linalg_8h.html#a07a01529159cc35e78c1f7731ac7bda6">vector</a>* mat_to_vec </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="linalg_8h.html#abc75382643898dd572498a574bf891c7">matrix</a> *&#160;</td>
          <td class="paramname"><em>mat</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts matrix into vector this function will "cast" the matrix into a vector by using the fact that they both have the same size. when calling this function, calling free() on the vector will free the matrix and vice versa. the input matrix can only be a matrix with dimensions 1 X N (a row matrix) </p>
<dl class="section return"><dt>Returns</dt><dd>vector* the new pointer for input matrix* </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>matrix* to be converted in terms of the newly formed vector </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="struct__matrix.html#a7e9feb52cfc0a9d7cba5320abcaa997a">_matrix::col</a>, and <a class="el" href="struct__matrix.html#a1087bec6a11b0773b4852c4ca49fc32a">_matrix::row</a>.</p>
<div class="fragment"><div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;                                {</div>
<div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;    assert(mat-&gt;<a class="code" href="struct__matrix.html#a1087bec6a11b0773b4852c4ca49fc32a">row</a> = 1);</div>
<div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;    mat-&gt;<a class="code" href="struct__matrix.html#a1087bec6a11b0773b4852c4ca49fc32a">row</a> = mat-&gt;<a class="code" href="struct__matrix.html#a7e9feb52cfc0a9d7cba5320abcaa997a">col</a>;</div>
<div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;    mat-&gt;<a class="code" href="struct__matrix.html#a7e9feb52cfc0a9d7cba5320abcaa997a">col</a> = 1;</div>
<div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;    <span class="keywordflow">return</span> (<a class="code" href="struct__vector.html">vector</a>*)mat;</div>
<div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;}</div>
<div class="ttc" id="struct__matrix_html_a1087bec6a11b0773b4852c4ca49fc32a"><div class="ttname"><a href="struct__matrix.html#a1087bec6a11b0773b4852c4ca49fc32a">_matrix::row</a></div><div class="ttdeci">size_t row</div><div class="ttdoc">the number of rows in the matrix </div><div class="ttdef"><b>Definition:</b> linalg.h:42</div></div>
<div class="ttc" id="struct__matrix_html_a7e9feb52cfc0a9d7cba5320abcaa997a"><div class="ttname"><a href="struct__matrix.html#a7e9feb52cfc0a9d7cba5320abcaa997a">_matrix::col</a></div><div class="ttdeci">size_t col</div><div class="ttdoc">the number of columns in the matrix </div><div class="ttdef"><b>Definition:</b> linalg.h:44</div></div>
<div class="ttc" id="struct__vector_html"><div class="ttname"><a href="struct__vector.html">_vector</a></div><div class="ttdoc">represents a vector padding is to make sure that matrix and vector both have the same byte size and a...</div><div class="ttdef"><b>Definition:</b> linalg.h:27</div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a2ac4400497d3a421f3f631d6329010b6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="linalg_8h.html#abc75382643898dd572498a574bf891c7">matrix</a>* mat_transpose </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="linalg_8h.html#abc75382643898dd572498a574bf891c7">matrix</a> *&#160;</td>
          <td class="paramname"><em>mat</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs matrix transpose this function will malloc for the user a matrix*. </p>
<dl class="section return"><dt>Returns</dt><dd>matrix* the newly transposed and malloced matrix </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>const matrix* the matrix to be transposed </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="struct__matrix.html#a7e9feb52cfc0a9d7cba5320abcaa997a">_matrix::col</a>, <a class="el" href="linalg_8h.html#ae0e32e641b8137c777d52988864296e3">MAT</a>, <a class="el" href="linalg_8c.html#a7821976cc30bc3131f3646bec1992d91">matrix_create()</a>, and <a class="el" href="struct__matrix.html#a1087bec6a11b0773b4852c4ca49fc32a">_matrix::row</a>.</p>

<p>Referenced by <a class="el" href="linalg_8h.html#ad41ec0281d3766f40963b77520ce600d">covmat()</a>.</p>
<div class="fragment"><div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;                                         {</div>
<div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;    <a class="code" href="struct__matrix.html">matrix</a>* retval = <a class="code" href="linalg_8c.html#a7821976cc30bc3131f3646bec1992d91">matrix_create</a>(mat-&gt;<a class="code" href="struct__matrix.html#a7e9feb52cfc0a9d7cba5320abcaa997a">col</a>, mat-&gt;<a class="code" href="struct__matrix.html#a1087bec6a11b0773b4852c4ca49fc32a">row</a>);</div>
<div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; mat-&gt;<a class="code" href="struct__matrix.html#a1087bec6a11b0773b4852c4ca49fc32a">row</a>; i ++) {</div>
<div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> j = 0; j &lt; mat-&gt;<a class="code" href="struct__matrix.html#a7e9feb52cfc0a9d7cba5320abcaa997a">col</a>; j ++) {</div>
<div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;            <a class="code" href="linalg_8h.html#ae0e32e641b8137c777d52988864296e3">MAT</a>(retval, j, i) = <a class="code" href="linalg_8h.html#ae0e32e641b8137c777d52988864296e3">MAT</a>(mat, i, j);</div>
<div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;        }</div>
<div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;    }</div>
<div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;    <span class="keywordflow">return</span> retval;</div>
<div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160;}</div>
<div class="ttc" id="struct__matrix_html"><div class="ttname"><a href="struct__matrix.html">_matrix</a></div><div class="ttdoc">represents a matrix between matrix and vector they are able to be casted into one another ...</div><div class="ttdef"><b>Definition:</b> linalg.h:40</div></div>
<div class="ttc" id="struct__matrix_html_a1087bec6a11b0773b4852c4ca49fc32a"><div class="ttname"><a href="struct__matrix.html#a1087bec6a11b0773b4852c4ca49fc32a">_matrix::row</a></div><div class="ttdeci">size_t row</div><div class="ttdoc">the number of rows in the matrix </div><div class="ttdef"><b>Definition:</b> linalg.h:42</div></div>
<div class="ttc" id="linalg_8c_html_a7821976cc30bc3131f3646bec1992d91"><div class="ttname"><a href="linalg_8c.html#a7821976cc30bc3131f3646bec1992d91">matrix_create</a></div><div class="ttdeci">matrix * matrix_create(size_t row, size_t col)</div><div class="ttdoc">Creates a matrix this function will malloc the exact space for the required dimensions. </div><div class="ttdef"><b>Definition:</b> linalg.c:22</div></div>
<div class="ttc" id="struct__matrix_html_a7e9feb52cfc0a9d7cba5320abcaa997a"><div class="ttname"><a href="struct__matrix.html#a7e9feb52cfc0a9d7cba5320abcaa997a">_matrix::col</a></div><div class="ttdeci">size_t col</div><div class="ttdoc">the number of columns in the matrix </div><div class="ttdef"><b>Definition:</b> linalg.h:44</div></div>
<div class="ttc" id="linalg_8h_html_ae0e32e641b8137c777d52988864296e3"><div class="ttname"><a href="linalg_8h.html#ae0e32e641b8137c777d52988864296e3">MAT</a></div><div class="ttdeci">#define MAT(m, x, y)</div><div class="ttdoc">macro for element access in a matrix struct </div><div class="ttdef"><b>Definition:</b> linalg.h:17</div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a9d1ca6441796b3d9c53f2a2923dc06c7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="linalg_8h.html#abc75382643898dd572498a574bf891c7">matrix</a>* matmat_addition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="linalg_8h.html#abc75382643898dd572498a574bf891c7">matrix</a> *&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="linalg_8h.html#abc75382643898dd572498a574bf891c7">matrix</a> *&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs standard matrix addition this function will malloc for the user a matrix*. </p>
<dl class="section return"><dt>Returns</dt><dd>matrix* newly malloced result of left plus right </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">left</td><td>const matrix* the matrix to be added to </td></tr>
    <tr><td class="paramname">right</td><td>const matrix* the matrix to be added </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="struct__matrix.html#a7e9feb52cfc0a9d7cba5320abcaa997a">_matrix::col</a>, <a class="el" href="linalg_8h.html#ae0e32e641b8137c777d52988864296e3">MAT</a>, <a class="el" href="linalg_8c.html#a7821976cc30bc3131f3646bec1992d91">matrix_create()</a>, and <a class="el" href="struct__matrix.html#a1087bec6a11b0773b4852c4ca49fc32a">_matrix::row</a>.</p>
<div class="fragment"><div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;                                                                 {</div>
<div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;    <a class="code" href="struct__matrix.html">matrix</a>* retval = <a class="code" href="linalg_8c.html#a7821976cc30bc3131f3646bec1992d91">matrix_create</a>(left-&gt;<a class="code" href="struct__matrix.html#a1087bec6a11b0773b4852c4ca49fc32a">row</a>, right-&gt;<a class="code" href="struct__matrix.html#a7e9feb52cfc0a9d7cba5320abcaa997a">col</a>);</div>
<div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; left-&gt;<a class="code" href="struct__matrix.html#a1087bec6a11b0773b4852c4ca49fc32a">row</a>; i ++) {</div>
<div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;       <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> j = 0; j &lt; right-&gt;<a class="code" href="struct__matrix.html#a7e9feb52cfc0a9d7cba5320abcaa997a">col</a>; j ++) {</div>
<div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;            <a class="code" href="linalg_8h.html#ae0e32e641b8137c777d52988864296e3">MAT</a>(retval, i, j) = <a class="code" href="linalg_8h.html#ae0e32e641b8137c777d52988864296e3">MAT</a>(left, i, j) + <a class="code" href="linalg_8h.html#ae0e32e641b8137c777d52988864296e3">MAT</a>(right, i, j);</div>
<div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;        }</div>
<div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;    }</div>
<div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;    <span class="keywordflow">return</span> retval;</div>
<div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;}</div>
<div class="ttc" id="struct__matrix_html"><div class="ttname"><a href="struct__matrix.html">_matrix</a></div><div class="ttdoc">represents a matrix between matrix and vector they are able to be casted into one another ...</div><div class="ttdef"><b>Definition:</b> linalg.h:40</div></div>
<div class="ttc" id="struct__matrix_html_a1087bec6a11b0773b4852c4ca49fc32a"><div class="ttname"><a href="struct__matrix.html#a1087bec6a11b0773b4852c4ca49fc32a">_matrix::row</a></div><div class="ttdeci">size_t row</div><div class="ttdoc">the number of rows in the matrix </div><div class="ttdef"><b>Definition:</b> linalg.h:42</div></div>
<div class="ttc" id="linalg_8c_html_a7821976cc30bc3131f3646bec1992d91"><div class="ttname"><a href="linalg_8c.html#a7821976cc30bc3131f3646bec1992d91">matrix_create</a></div><div class="ttdeci">matrix * matrix_create(size_t row, size_t col)</div><div class="ttdoc">Creates a matrix this function will malloc the exact space for the required dimensions. </div><div class="ttdef"><b>Definition:</b> linalg.c:22</div></div>
<div class="ttc" id="struct__matrix_html_a7e9feb52cfc0a9d7cba5320abcaa997a"><div class="ttname"><a href="struct__matrix.html#a7e9feb52cfc0a9d7cba5320abcaa997a">_matrix::col</a></div><div class="ttdeci">size_t col</div><div class="ttdoc">the number of columns in the matrix </div><div class="ttdef"><b>Definition:</b> linalg.h:44</div></div>
<div class="ttc" id="linalg_8h_html_ae0e32e641b8137c777d52988864296e3"><div class="ttname"><a href="linalg_8h.html#ae0e32e641b8137c777d52988864296e3">MAT</a></div><div class="ttdeci">#define MAT(m, x, y)</div><div class="ttdoc">macro for element access in a matrix struct </div><div class="ttdef"><b>Definition:</b> linalg.h:17</div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a40a3d6442169157a458362f5e85c5843"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="linalg_8h.html#abc75382643898dd572498a574bf891c7">matrix</a>* matmat_multiply </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="linalg_8h.html#abc75382643898dd572498a574bf891c7">matrix</a> *&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="linalg_8h.html#abc75382643898dd572498a574bf891c7">matrix</a> *&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs standard matrix multiplication this function will malloc for the user a matrix*. </p>
<dl class="section return"><dt>Returns</dt><dd>matrix* newly malloced result of left times right </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">left</td><td>const matrix* the matrix to be multiplied to </td></tr>
    <tr><td class="paramname">right</td><td>const matrix* the matrix to be multiplied </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="struct__matrix.html#a7e9feb52cfc0a9d7cba5320abcaa997a">_matrix::col</a>, <a class="el" href="linalg_8h.html#ae0e32e641b8137c777d52988864296e3">MAT</a>, <a class="el" href="linalg_8c.html#a7821976cc30bc3131f3646bec1992d91">matrix_create()</a>, and <a class="el" href="struct__matrix.html#a1087bec6a11b0773b4852c4ca49fc32a">_matrix::row</a>.</p>

<p>Referenced by <a class="el" href="linalg_8h.html#ad41ec0281d3766f40963b77520ce600d">covmat()</a>.</p>
<div class="fragment"><div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;                                                                 {</div>
<div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;    <a class="code" href="struct__matrix.html">matrix</a>* retval = <a class="code" href="linalg_8c.html#a7821976cc30bc3131f3646bec1992d91">matrix_create</a>(left-&gt;<a class="code" href="struct__matrix.html#a1087bec6a11b0773b4852c4ca49fc32a">row</a>, right-&gt;<a class="code" href="struct__matrix.html#a7e9feb52cfc0a9d7cba5320abcaa997a">col</a>);</div>
<div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;    <span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> i = 0; i &lt; left-&gt;<a class="code" href="struct__matrix.html#a1087bec6a11b0773b4852c4ca49fc32a">row</a>; i ++) {</div>
<div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;        <span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> j = 0; j &lt; right-&gt;<a class="code" href="struct__matrix.html#a7e9feb52cfc0a9d7cba5320abcaa997a">col</a>; j ++) {</div>
<div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;            <a class="code" href="linalg_8h.html#ae0e32e641b8137c777d52988864296e3">MAT</a>(retval,i,j) = 0;</div>
<div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;            <span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> k = 0; k &lt; left-&gt;<a class="code" href="struct__matrix.html#a7e9feb52cfc0a9d7cba5320abcaa997a">col</a>; k ++) {</div>
<div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;                <a class="code" href="linalg_8h.html#ae0e32e641b8137c777d52988864296e3">MAT</a>(retval, i, j) += <a class="code" href="linalg_8h.html#ae0e32e641b8137c777d52988864296e3">MAT</a>(left, i, k) * <a class="code" href="linalg_8h.html#ae0e32e641b8137c777d52988864296e3">MAT</a>(right, k, j);</div>
<div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;            }</div>
<div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;        }</div>
<div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;    }   </div>
<div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;    <span class="keywordflow">return</span> retval;</div>
<div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;}</div>
<div class="ttc" id="struct__matrix_html"><div class="ttname"><a href="struct__matrix.html">_matrix</a></div><div class="ttdoc">represents a matrix between matrix and vector they are able to be casted into one another ...</div><div class="ttdef"><b>Definition:</b> linalg.h:40</div></div>
<div class="ttc" id="struct__matrix_html_a1087bec6a11b0773b4852c4ca49fc32a"><div class="ttname"><a href="struct__matrix.html#a1087bec6a11b0773b4852c4ca49fc32a">_matrix::row</a></div><div class="ttdeci">size_t row</div><div class="ttdoc">the number of rows in the matrix </div><div class="ttdef"><b>Definition:</b> linalg.h:42</div></div>
<div class="ttc" id="linalg_8c_html_a7821976cc30bc3131f3646bec1992d91"><div class="ttname"><a href="linalg_8c.html#a7821976cc30bc3131f3646bec1992d91">matrix_create</a></div><div class="ttdeci">matrix * matrix_create(size_t row, size_t col)</div><div class="ttdoc">Creates a matrix this function will malloc the exact space for the required dimensions. </div><div class="ttdef"><b>Definition:</b> linalg.c:22</div></div>
<div class="ttc" id="struct__matrix_html_a7e9feb52cfc0a9d7cba5320abcaa997a"><div class="ttname"><a href="struct__matrix.html#a7e9feb52cfc0a9d7cba5320abcaa997a">_matrix::col</a></div><div class="ttdeci">size_t col</div><div class="ttdoc">the number of columns in the matrix </div><div class="ttdef"><b>Definition:</b> linalg.h:44</div></div>
<div class="ttc" id="linalg_8h_html_ae0e32e641b8137c777d52988864296e3"><div class="ttname"><a href="linalg_8h.html#ae0e32e641b8137c777d52988864296e3">MAT</a></div><div class="ttdeci">#define MAT(m, x, y)</div><div class="ttdoc">macro for element access in a matrix struct </div><div class="ttdef"><b>Definition:</b> linalg.h:17</div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a6b7138d5fae752feceeb9faea996cb54"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="linalg_8h.html#abc75382643898dd572498a574bf891c7">matrix</a>* matmat_subtraction </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="linalg_8h.html#abc75382643898dd572498a574bf891c7">matrix</a> *&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="linalg_8h.html#abc75382643898dd572498a574bf891c7">matrix</a> *&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs standard matrix subtration this function will malloc for the user a matrix*. </p>
<dl class="section return"><dt>Returns</dt><dd>matrix* newly malloced result of left minus right </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">left</td><td>const matrix* the matrix to be subtracted from </td></tr>
    <tr><td class="paramname">right</td><td>const matrix* the matrix to be subtrated </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="struct__matrix.html#a7e9feb52cfc0a9d7cba5320abcaa997a">_matrix::col</a>, <a class="el" href="linalg_8h.html#ae0e32e641b8137c777d52988864296e3">MAT</a>, <a class="el" href="linalg_8c.html#a7821976cc30bc3131f3646bec1992d91">matrix_create()</a>, and <a class="el" href="struct__matrix.html#a1087bec6a11b0773b4852c4ca49fc32a">_matrix::row</a>.</p>
<div class="fragment"><div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;                                                                    {</div>
<div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;    <a class="code" href="struct__matrix.html">matrix</a>* retval = <a class="code" href="linalg_8c.html#a7821976cc30bc3131f3646bec1992d91">matrix_create</a>(left-&gt;<a class="code" href="struct__matrix.html#a1087bec6a11b0773b4852c4ca49fc32a">row</a>, right-&gt;<a class="code" href="struct__matrix.html#a7e9feb52cfc0a9d7cba5320abcaa997a">col</a>);</div>
<div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; left-&gt;<a class="code" href="struct__matrix.html#a1087bec6a11b0773b4852c4ca49fc32a">row</a>; i ++) {</div>
<div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> j = 0; j &lt; right-&gt;<a class="code" href="struct__matrix.html#a7e9feb52cfc0a9d7cba5320abcaa997a">col</a>; j ++) {</div>
<div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;            <a class="code" href="linalg_8h.html#ae0e32e641b8137c777d52988864296e3">MAT</a>(retval, i, j) = <a class="code" href="linalg_8h.html#ae0e32e641b8137c777d52988864296e3">MAT</a>(left, i, j) - <a class="code" href="linalg_8h.html#ae0e32e641b8137c777d52988864296e3">MAT</a>(right, i, j);</div>
<div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;        }</div>
<div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;    }</div>
<div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;    <span class="keywordflow">return</span> retval;</div>
<div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;}</div>
<div class="ttc" id="struct__matrix_html"><div class="ttname"><a href="struct__matrix.html">_matrix</a></div><div class="ttdoc">represents a matrix between matrix and vector they are able to be casted into one another ...</div><div class="ttdef"><b>Definition:</b> linalg.h:40</div></div>
<div class="ttc" id="struct__matrix_html_a1087bec6a11b0773b4852c4ca49fc32a"><div class="ttname"><a href="struct__matrix.html#a1087bec6a11b0773b4852c4ca49fc32a">_matrix::row</a></div><div class="ttdeci">size_t row</div><div class="ttdoc">the number of rows in the matrix </div><div class="ttdef"><b>Definition:</b> linalg.h:42</div></div>
<div class="ttc" id="linalg_8c_html_a7821976cc30bc3131f3646bec1992d91"><div class="ttname"><a href="linalg_8c.html#a7821976cc30bc3131f3646bec1992d91">matrix_create</a></div><div class="ttdeci">matrix * matrix_create(size_t row, size_t col)</div><div class="ttdoc">Creates a matrix this function will malloc the exact space for the required dimensions. </div><div class="ttdef"><b>Definition:</b> linalg.c:22</div></div>
<div class="ttc" id="struct__matrix_html_a7e9feb52cfc0a9d7cba5320abcaa997a"><div class="ttname"><a href="struct__matrix.html#a7e9feb52cfc0a9d7cba5320abcaa997a">_matrix::col</a></div><div class="ttdeci">size_t col</div><div class="ttdoc">the number of columns in the matrix </div><div class="ttdef"><b>Definition:</b> linalg.h:44</div></div>
<div class="ttc" id="linalg_8h_html_ae0e32e641b8137c777d52988864296e3"><div class="ttname"><a href="linalg_8h.html#ae0e32e641b8137c777d52988864296e3">MAT</a></div><div class="ttdeci">#define MAT(m, x, y)</div><div class="ttdoc">macro for element access in a matrix struct </div><div class="ttdef"><b>Definition:</b> linalg.h:17</div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a7821976cc30bc3131f3646bec1992d91"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="linalg_8h.html#abc75382643898dd572498a574bf891c7">matrix</a>* matrix_create </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>col</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a matrix this function will malloc the exact space for the required dimensions. </p>
<dl class="section return"><dt>Returns</dt><dd>matrix* the newly malloced matrix </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>size_t the desired number of rows in the matrix </td></tr>
    <tr><td class="paramname">col</td><td>size_t the desired number of columns in the matrix </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="struct__matrix.html#a7e9feb52cfc0a9d7cba5320abcaa997a">_matrix::col</a>, and <a class="el" href="struct__matrix.html#a1087bec6a11b0773b4852c4ca49fc32a">_matrix::row</a>.</p>

<p>Referenced by <a class="el" href="linalg_8h.html#a2ac4400497d3a421f3f631d6329010b6">mat_transpose()</a>, <a class="el" href="linalg_8h.html#a9d1ca6441796b3d9c53f2a2923dc06c7">matmat_addition()</a>, <a class="el" href="linalg_8h.html#a40a3d6442169157a458362f5e85c5843">matmat_multiply()</a>, <a class="el" href="linalg_8h.html#a6b7138d5fae752feceeb9faea996cb54">matmat_subtraction()</a>, and <a class="el" href="linalg_8h.html#a32cb81b161008e2b1fd862ae9d45caa2">matscalar_multiply()</a>.</p>
<div class="fragment"><div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;                                              {</div>
<div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;    <span class="keywordflow">if</span>(row &lt;= 0 || col &lt;= 0) {</div>
<div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;        <span class="keywordflow">return</span> NULL;</div>
<div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;    }</div>
<div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;    <a class="code" href="struct__matrix.html">matrix</a>* retval =  malloc((row * col * <span class="keyword">sizeof</span>(<span class="keywordtype">double</span>)) + (2 * <span class="keyword">sizeof</span>(<span class="keywordtype">size_t</span>)));</div>
<div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;    retval-&gt;<a class="code" href="struct__matrix.html#a1087bec6a11b0773b4852c4ca49fc32a">row</a> = row;</div>
<div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;    retval-&gt;<a class="code" href="struct__matrix.html#a7e9feb52cfc0a9d7cba5320abcaa997a">col</a> = col;</div>
<div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;    <span class="keywordflow">return</span> retval;</div>
<div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;}</div>
<div class="ttc" id="struct__matrix_html"><div class="ttname"><a href="struct__matrix.html">_matrix</a></div><div class="ttdoc">represents a matrix between matrix and vector they are able to be casted into one another ...</div><div class="ttdef"><b>Definition:</b> linalg.h:40</div></div>
<div class="ttc" id="struct__matrix_html_a1087bec6a11b0773b4852c4ca49fc32a"><div class="ttname"><a href="struct__matrix.html#a1087bec6a11b0773b4852c4ca49fc32a">_matrix::row</a></div><div class="ttdeci">size_t row</div><div class="ttdoc">the number of rows in the matrix </div><div class="ttdef"><b>Definition:</b> linalg.h:42</div></div>
<div class="ttc" id="struct__matrix_html_a7e9feb52cfc0a9d7cba5320abcaa997a"><div class="ttname"><a href="struct__matrix.html#a7e9feb52cfc0a9d7cba5320abcaa997a">_matrix::col</a></div><div class="ttdeci">size_t col</div><div class="ttdoc">the number of columns in the matrix </div><div class="ttdef"><b>Definition:</b> linalg.h:44</div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a41ab46fdaa678c67aef38d873870a98d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void matrix_reshape </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="linalg_8h.html#abc75382643898dd572498a574bf891c7">matrix</a> *&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>col</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reshapes the matrix this function will reshape the matrix in constant time. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>matrix* to be reshaped </td></tr>
    <tr><td class="paramname">row</td><td>size_t the new row </td></tr>
    <tr><td class="paramname">col</td><td>size_t the new column </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="struct__matrix.html#a7e9feb52cfc0a9d7cba5320abcaa997a">_matrix::col</a>, and <a class="el" href="struct__matrix.html#a1087bec6a11b0773b4852c4ca49fc32a">_matrix::row</a>.</p>
<div class="fragment"><div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;                                                         {</div>
<div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;    mat-&gt;<a class="code" href="struct__matrix.html#a1087bec6a11b0773b4852c4ca49fc32a">row</a> = row;</div>
<div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;    mat-&gt;<a class="code" href="struct__matrix.html#a7e9feb52cfc0a9d7cba5320abcaa997a">col</a> = col;</div>
<div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;}</div>
<div class="ttc" id="struct__matrix_html_a1087bec6a11b0773b4852c4ca49fc32a"><div class="ttname"><a href="struct__matrix.html#a1087bec6a11b0773b4852c4ca49fc32a">_matrix::row</a></div><div class="ttdeci">size_t row</div><div class="ttdoc">the number of rows in the matrix </div><div class="ttdef"><b>Definition:</b> linalg.h:42</div></div>
<div class="ttc" id="struct__matrix_html_a7e9feb52cfc0a9d7cba5320abcaa997a"><div class="ttname"><a href="struct__matrix.html#a7e9feb52cfc0a9d7cba5320abcaa997a">_matrix::col</a></div><div class="ttdeci">size_t col</div><div class="ttdoc">the number of columns in the matrix </div><div class="ttdef"><b>Definition:</b> linalg.h:44</div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a98269f4c3f77b32dc52e30108713cb28"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="linalg_8h.html#abc75382643898dd572498a574bf891c7">matrix</a>* matscalar_divide </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="linalg_8h.html#abc75382643898dd572498a574bf891c7">matrix</a> *&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>scalar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs scalar division of a matrix this function will malloc for the user a matrix*. </p>
<dl class="section return"><dt>Returns</dt><dd>matrix* that is the result of element wise division of the matrix by the scalar </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>const matrix* the input matrix </td></tr>
    <tr><td class="paramname">scalar</td><td>const double the input scalar </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="linalg_8c.html#a32cb81b161008e2b1fd862ae9d45caa2">matscalar_multiply()</a>.</p>

<p>Referenced by <a class="el" href="linalg_8h.html#ad41ec0281d3766f40963b77520ce600d">covmat()</a>.</p>
<div class="fragment"><div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;                                                                 {</div>
<div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="linalg_8c.html#a32cb81b161008e2b1fd862ae9d45caa2">matscalar_multiply</a>(mat, 1/scalar);</div>
<div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;}</div>
<div class="ttc" id="linalg_8c_html_a32cb81b161008e2b1fd862ae9d45caa2"><div class="ttname"><a href="linalg_8c.html#a32cb81b161008e2b1fd862ae9d45caa2">matscalar_multiply</a></div><div class="ttdeci">matrix * matscalar_multiply(const matrix *mat, const double scalar)</div><div class="ttdoc">Performs scalar multiplication of a matrix this function will malloc for the user a matrix*...</div><div class="ttdef"><b>Definition:</b> linalg.c:165</div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a32cb81b161008e2b1fd862ae9d45caa2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="linalg_8h.html#abc75382643898dd572498a574bf891c7">matrix</a>* matscalar_multiply </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="linalg_8h.html#abc75382643898dd572498a574bf891c7">matrix</a> *&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>scalar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs scalar multiplication of a matrix this function will malloc for the user a matrix*. </p>
<dl class="section return"><dt>Returns</dt><dd>matrix* that is the result of element wise multiplication of the matrix by the scalar </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>const matrix* the input matrix </td></tr>
    <tr><td class="paramname">scalar</td><td>const double the input scalar </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="struct__matrix.html#a7e9feb52cfc0a9d7cba5320abcaa997a">_matrix::col</a>, <a class="el" href="linalg_8h.html#ae0e32e641b8137c777d52988864296e3">MAT</a>, <a class="el" href="linalg_8c.html#a7821976cc30bc3131f3646bec1992d91">matrix_create()</a>, and <a class="el" href="struct__matrix.html#a1087bec6a11b0773b4852c4ca49fc32a">_matrix::row</a>.</p>

<p>Referenced by <a class="el" href="linalg_8h.html#a98269f4c3f77b32dc52e30108713cb28">matscalar_divide()</a>.</p>
<div class="fragment"><div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;                                                                   {</div>
<div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;    <a class="code" href="struct__matrix.html">matrix</a>* retval = <a class="code" href="linalg_8c.html#a7821976cc30bc3131f3646bec1992d91">matrix_create</a>(mat-&gt;<a class="code" href="struct__matrix.html#a1087bec6a11b0773b4852c4ca49fc32a">row</a>, mat-&gt;<a class="code" href="struct__matrix.html#a7e9feb52cfc0a9d7cba5320abcaa997a">col</a>);</div>
<div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; mat-&gt;<a class="code" href="struct__matrix.html#a1087bec6a11b0773b4852c4ca49fc32a">row</a>; i++) {</div>
<div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> j = 0; j &lt; mat-&gt;<a class="code" href="struct__matrix.html#a7e9feb52cfc0a9d7cba5320abcaa997a">col</a>; j++) {</div>
<div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;            <a class="code" href="linalg_8h.html#ae0e32e641b8137c777d52988864296e3">MAT</a>(retval,i,j) = <a class="code" href="linalg_8h.html#ae0e32e641b8137c777d52988864296e3">MAT</a>(mat,i,j) * scalar;</div>
<div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;        }</div>
<div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;    }</div>
<div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;    <span class="keywordflow">return</span> retval;</div>
<div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;}</div>
<div class="ttc" id="struct__matrix_html"><div class="ttname"><a href="struct__matrix.html">_matrix</a></div><div class="ttdoc">represents a matrix between matrix and vector they are able to be casted into one another ...</div><div class="ttdef"><b>Definition:</b> linalg.h:40</div></div>
<div class="ttc" id="struct__matrix_html_a1087bec6a11b0773b4852c4ca49fc32a"><div class="ttname"><a href="struct__matrix.html#a1087bec6a11b0773b4852c4ca49fc32a">_matrix::row</a></div><div class="ttdeci">size_t row</div><div class="ttdoc">the number of rows in the matrix </div><div class="ttdef"><b>Definition:</b> linalg.h:42</div></div>
<div class="ttc" id="linalg_8c_html_a7821976cc30bc3131f3646bec1992d91"><div class="ttname"><a href="linalg_8c.html#a7821976cc30bc3131f3646bec1992d91">matrix_create</a></div><div class="ttdeci">matrix * matrix_create(size_t row, size_t col)</div><div class="ttdoc">Creates a matrix this function will malloc the exact space for the required dimensions. </div><div class="ttdef"><b>Definition:</b> linalg.c:22</div></div>
<div class="ttc" id="struct__matrix_html_a7e9feb52cfc0a9d7cba5320abcaa997a"><div class="ttname"><a href="struct__matrix.html#a7e9feb52cfc0a9d7cba5320abcaa997a">_matrix::col</a></div><div class="ttdeci">size_t col</div><div class="ttdoc">the number of columns in the matrix </div><div class="ttdef"><b>Definition:</b> linalg.h:44</div></div>
<div class="ttc" id="linalg_8h_html_ae0e32e641b8137c777d52988864296e3"><div class="ttname"><a href="linalg_8h.html#ae0e32e641b8137c777d52988864296e3">MAT</a></div><div class="ttdeci">#define MAT(m, x, y)</div><div class="ttdoc">macro for element access in a matrix struct </div><div class="ttdef"><b>Definition:</b> linalg.h:17</div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="af88415d8996030537851e2c48d5337c4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="linalg_8h.html#a07a01529159cc35e78c1f7731ac7bda6">vector</a>* matvec_multiply </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="linalg_8h.html#abc75382643898dd572498a574bf891c7">matrix</a> *&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="linalg_8h.html#a07a01529159cc35e78c1f7731ac7bda6">vector</a> *&#160;</td>
          <td class="paramname"><em>vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs matrix vector multiplication this function will malloc for the user a vector* if the matrix is of size M by N and the vector N, the resulting row vector will be of size M. </p>
<dl class="section return"><dt>Returns</dt><dd>vector* newly malloced result of matrix vector multiplication </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>const matrix* the input matrix </td></tr>
    <tr><td class="paramname">vec</td><td>const vector* the input vector </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="struct__matrix.html#a7e9feb52cfc0a9d7cba5320abcaa997a">_matrix::col</a>, <a class="el" href="struct__vector.html#abcf7d1342126a90769b2a05126897859">_vector::data</a>, <a class="el" href="struct__matrix.html#ab0c92b382e007327a4cc5fc6818c77a9">_matrix::data</a>, <a class="el" href="linalg_8c.html#afc298e7d7d6a208e71ef073948b651d2">dot_product()</a>, <a class="el" href="struct__vector.html#a1ed8dca78f3e589deb8dad9b53aec3fa">_vector::size</a>, <a class="el" href="linalg_8h.html#a03e904294c904b01194a25323fc2f6ec">VEC</a>, and <a class="el" href="linalg_8c.html#a7040be230e99648e77b0932600bf55ef">vector_create()</a>.</p>
<div class="fragment"><div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;                                                              {</div>
<div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;    <span class="keywordflow">if</span>(vec == NULL  || mat == NULL) {</div>
<div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;        <span class="keywordflow">return</span> NULL;</div>
<div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;    }</div>
<div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;    <a class="code" href="struct__vector.html">vector</a>* retval = <a class="code" href="linalg_8c.html#a7040be230e99648e77b0932600bf55ef">vector_create</a>(vec-&gt;<a class="code" href="struct__vector.html#a1ed8dca78f3e589deb8dad9b53aec3fa">size</a>);</div>
<div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;    <span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> i = 0; i &lt; retval-&gt;<a class="code" href="struct__vector.html#a1ed8dca78f3e589deb8dad9b53aec3fa">size</a>; i++) { </div>
<div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;        <a class="code" href="linalg_8h.html#a03e904294c904b01194a25323fc2f6ec">VEC</a>(retval,i) = <a class="code" href="linalg_8c.html#afc298e7d7d6a208e71ef073948b651d2">dot_product</a>(((<span class="keywordtype">double</span>*)(mat-&gt;<a class="code" href="struct__matrix.html#ab0c92b382e007327a4cc5fc6818c77a9">data</a>) + (mat-&gt;<a class="code" href="struct__matrix.html#a7e9feb52cfc0a9d7cba5320abcaa997a">col</a> * i)), (<span class="keywordtype">double</span>*)vec-&gt;<a class="code" href="struct__vector.html#abcf7d1342126a90769b2a05126897859">data</a>, vec-&gt;<a class="code" href="struct__vector.html#a1ed8dca78f3e589deb8dad9b53aec3fa">size</a>);</div>
<div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;    }</div>
<div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;    <span class="keywordflow">return</span> retval;</div>
<div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;}</div>
<div class="ttc" id="struct__vector_html_abcf7d1342126a90769b2a05126897859"><div class="ttname"><a href="struct__vector.html#abcf7d1342126a90769b2a05126897859">_vector::data</a></div><div class="ttdeci">double data[]</div><div class="ttdoc">the elements of the vector </div><div class="ttdef"><b>Definition:</b> linalg.h:33</div></div>
<div class="ttc" id="linalg_8c_html_afc298e7d7d6a208e71ef073948b651d2"><div class="ttname"><a href="linalg_8c.html#afc298e7d7d6a208e71ef073948b651d2">dot_product</a></div><div class="ttdeci">double dot_product(const double *left, const double *right, int length)</div><div class="ttdoc">Performs dot product on two double* this function will malloc for the user a double arrays must be of...</div><div class="ttdef"><b>Definition:</b> linalg.c:57</div></div>
<div class="ttc" id="linalg_8c_html_a7040be230e99648e77b0932600bf55ef"><div class="ttname"><a href="linalg_8c.html#a7040be230e99648e77b0932600bf55ef">vector_create</a></div><div class="ttdeci">vector * vector_create(size_t size)</div><div class="ttdoc">Creates a vector this function will malloc the exact space for the required dimensions. </div><div class="ttdef"><b>Definition:</b> linalg.c:11</div></div>
<div class="ttc" id="linalg_8h_html_a03e904294c904b01194a25323fc2f6ec"><div class="ttname"><a href="linalg_8h.html#a03e904294c904b01194a25323fc2f6ec">VEC</a></div><div class="ttdeci">#define VEC(v, x)</div><div class="ttdoc">macro for element access in a vector struct </div><div class="ttdef"><b>Definition:</b> linalg.h:19</div></div>
<div class="ttc" id="struct__matrix_html_a7e9feb52cfc0a9d7cba5320abcaa997a"><div class="ttname"><a href="struct__matrix.html#a7e9feb52cfc0a9d7cba5320abcaa997a">_matrix::col</a></div><div class="ttdeci">size_t col</div><div class="ttdoc">the number of columns in the matrix </div><div class="ttdef"><b>Definition:</b> linalg.h:44</div></div>
<div class="ttc" id="struct__matrix_html_ab0c92b382e007327a4cc5fc6818c77a9"><div class="ttname"><a href="struct__matrix.html#ab0c92b382e007327a4cc5fc6818c77a9">_matrix::data</a></div><div class="ttdeci">double data[]</div><div class="ttdoc">row wise expansion of the elements in the matrix </div><div class="ttdef"><b>Definition:</b> linalg.h:46</div></div>
<div class="ttc" id="struct__vector_html_a1ed8dca78f3e589deb8dad9b53aec3fa"><div class="ttname"><a href="struct__vector.html#a1ed8dca78f3e589deb8dad9b53aec3fa">_vector::size</a></div><div class="ttdeci">size_t size</div><div class="ttdoc">the number of elements in the vector </div><div class="ttdef"><b>Definition:</b> linalg.h:29</div></div>
<div class="ttc" id="struct__vector_html"><div class="ttname"><a href="struct__vector.html">_vector</a></div><div class="ttdoc">represents a vector padding is to make sure that matrix and vector both have the same byte size and a...</div><div class="ttdef"><b>Definition:</b> linalg.h:27</div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="adbfad21fe7e851455d625173e67b8504"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vec_append </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="linalg_8h.html#a07a01529159cc35e78c1f7731ac7bda6">vector</a> **&#160;</td>
          <td class="paramname"><em>vec_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="linalg_8h.html#a07a01529159cc35e78c1f7731ac7bda6">vector</a> *&#160;</td>
          <td class="paramname"><em>vec_b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Appends vector b to vector a this function will realloc for the user vector a and free vector b. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec_a</td><td>vector** the vector to be realloced </td></tr>
    <tr><td class="paramname">vec_b</td><td>vector* the vector to be appended and freed thereafter </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="struct__vector.html#abcf7d1342126a90769b2a05126897859">_vector::data</a>, <a class="el" href="struct__vector.html#a1ed8dca78f3e589deb8dad9b53aec3fa">_vector::size</a>, and <a class="el" href="linalg_8c.html#a7040be230e99648e77b0932600bf55ef">vector_create()</a>.</p>

<p>Referenced by <a class="el" href="tiff__util_8h.html#a8f8b0a0f74bb3416dd0214aa0a68130e">tiff_stream_to_vec()</a>.</p>
<div class="fragment"><div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;{</div>
<div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;    <span class="keywordtype">void</span>* saved_vec_a = *vec_a;</div>
<div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160;    <a class="code" href="struct__vector.html">vector</a>* buffer = <a class="code" href="linalg_8c.html#a7040be230e99648e77b0932600bf55ef">vector_create</a>(vec_b-&gt;<a class="code" href="struct__vector.html#a1ed8dca78f3e589deb8dad9b53aec3fa">size</a>);</div>
<div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;    memcpy(buffer, vec_b, <span class="keyword">sizeof</span>(<span class="keywordtype">double</span>) * vec_b-&gt;<a class="code" href="struct__vector.html#a1ed8dca78f3e589deb8dad9b53aec3fa">size</a> + (2 * <span class="keyword">sizeof</span>(<span class="keywordtype">size_t</span>)));</div>
<div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;    <span class="keywordtype">size_t</span> newSize = (*vec_a)-&gt;size + buffer-&gt;<a class="code" href="struct__vector.html#a1ed8dca78f3e589deb8dad9b53aec3fa">size</a>;</div>
<div class="line"><a name="l00198"></a><span class="lineno">  198</span>&#160;    <span class="keywordtype">void</span>* dest = *vec_a;</div>
<div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;    <span class="keywordtype">void</span>* arrv = NULL;</div>
<div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;    arrv = realloc(dest, <span class="keyword">sizeof</span>(<span class="keywordtype">double</span>) * newSize + (2 * <span class="keyword">sizeof</span>(<span class="keywordtype">size_t</span>)));</div>
<div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;    *vec_a = arrv;    </div>
<div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;    memcpy((*vec_a)-&gt;data + (*vec_a)-&gt;size, buffer-&gt;<a class="code" href="struct__vector.html#abcf7d1342126a90769b2a05126897859">data</a>, buffer-&gt;<a class="code" href="struct__vector.html#a1ed8dca78f3e589deb8dad9b53aec3fa">size</a> *<span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));</div>
<div class="line"><a name="l00203"></a><span class="lineno">  203</span>&#160;    (*vec_a)-&gt;size = newSize;</div>
<div class="line"><a name="l00204"></a><span class="lineno">  204</span>&#160;    free(buffer);</div>
<div class="line"><a name="l00205"></a><span class="lineno">  205</span>&#160;    <span class="keywordflow">if</span>(saved_vec_a != vec_b)</div>
<div class="line"><a name="l00206"></a><span class="lineno">  206</span>&#160;    {</div>
<div class="line"><a name="l00207"></a><span class="lineno">  207</span>&#160;        free(vec_b);</div>
<div class="line"><a name="l00208"></a><span class="lineno">  208</span>&#160;    }</div>
<div class="line"><a name="l00209"></a><span class="lineno">  209</span>&#160;}</div>
<div class="ttc" id="struct__vector_html_abcf7d1342126a90769b2a05126897859"><div class="ttname"><a href="struct__vector.html#abcf7d1342126a90769b2a05126897859">_vector::data</a></div><div class="ttdeci">double data[]</div><div class="ttdoc">the elements of the vector </div><div class="ttdef"><b>Definition:</b> linalg.h:33</div></div>
<div class="ttc" id="linalg_8c_html_a7040be230e99648e77b0932600bf55ef"><div class="ttname"><a href="linalg_8c.html#a7040be230e99648e77b0932600bf55ef">vector_create</a></div><div class="ttdeci">vector * vector_create(size_t size)</div><div class="ttdoc">Creates a vector this function will malloc the exact space for the required dimensions. </div><div class="ttdef"><b>Definition:</b> linalg.c:11</div></div>
<div class="ttc" id="struct__vector_html_a1ed8dca78f3e589deb8dad9b53aec3fa"><div class="ttname"><a href="struct__vector.html#a1ed8dca78f3e589deb8dad9b53aec3fa">_vector::size</a></div><div class="ttdeci">size_t size</div><div class="ttdoc">the number of elements in the vector </div><div class="ttdef"><b>Definition:</b> linalg.h:29</div></div>
<div class="ttc" id="struct__vector_html"><div class="ttname"><a href="struct__vector.html">_vector</a></div><div class="ttdoc">represents a vector padding is to make sure that matrix and vector both have the same byte size and a...</div><div class="ttdef"><b>Definition:</b> linalg.h:27</div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a1d2e72678bf82c44ba57020fc8588868"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vec_print </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="linalg_8h.html#a07a01529159cc35e78c1f7731ac7bda6">vector</a> *&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>prints the vector this function will not modify the vector and print to stdout </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>const vector* the vector to be printed </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="struct__vector.html#abcf7d1342126a90769b2a05126897859">_vector::data</a>, and <a class="el" href="struct__vector.html#a1ed8dca78f3e589deb8dad9b53aec3fa">_vector::size</a>.</p>
<div class="fragment"><div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;                                  {</div>
<div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;    <span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> i = 0; i &lt; vec-&gt;<a class="code" href="struct__vector.html#a1ed8dca78f3e589deb8dad9b53aec3fa">size</a>; i ++) {</div>
<div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;        printf(<span class="stringliteral">&quot;%f &quot;</span>, vec-&gt;<a class="code" href="struct__vector.html#abcf7d1342126a90769b2a05126897859">data</a>[i]);</div>
<div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;    }</div>
<div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;    printf(<span class="stringliteral">&quot;\n&quot;</span>);</div>
<div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;}</div>
<div class="ttc" id="struct__vector_html_abcf7d1342126a90769b2a05126897859"><div class="ttname"><a href="struct__vector.html#abcf7d1342126a90769b2a05126897859">_vector::data</a></div><div class="ttdeci">double data[]</div><div class="ttdoc">the elements of the vector </div><div class="ttdef"><b>Definition:</b> linalg.h:33</div></div>
<div class="ttc" id="struct__vector_html_a1ed8dca78f3e589deb8dad9b53aec3fa"><div class="ttname"><a href="struct__vector.html#a1ed8dca78f3e589deb8dad9b53aec3fa">_vector::size</a></div><div class="ttdeci">size_t size</div><div class="ttdoc">the number of elements in the vector </div><div class="ttdef"><b>Definition:</b> linalg.h:29</div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a8a5d3412faa2267345b3a7d1ca6f58c1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="linalg_8h.html#abc75382643898dd572498a574bf891c7">matrix</a>* vec_to_mat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="linalg_8h.html#a07a01529159cc35e78c1f7731ac7bda6">vector</a> *&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>orientation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts vector into matrix this function will "cast" the vector into a matrix by using the fact that they both have the same size. when calling this function, calling free() on the matrix will free the vector and vice versa. </p>
<dl class="section return"><dt>Returns</dt><dd>matrix* the new pointer for input vector* </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>vector* to be converted </td></tr>
    <tr><td class="paramname">orientation</td><td>int 1 is Row-wise and 0 is Column-wise in terms of the newly formed matrix </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="struct__vector.html#a4165a40cc39bfd874677299c943b290f">_vector::padding</a>, and <a class="el" href="struct__vector.html#a1ed8dca78f3e589deb8dad9b53aec3fa">_vector::size</a>.</p>
<div class="fragment"><div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;                                                 {</div>
<div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;    <span class="keywordflow">if</span>(orientation == 1) {</div>
<div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;        vec-&gt;<a class="code" href="struct__vector.html#a4165a40cc39bfd874677299c943b290f">padding</a> = vec-&gt;<a class="code" href="struct__vector.html#a1ed8dca78f3e589deb8dad9b53aec3fa">size</a>;</div>
<div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;        vec-&gt;<a class="code" href="struct__vector.html#a1ed8dca78f3e589deb8dad9b53aec3fa">size</a> = 1;</div>
<div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;    } <span class="keywordflow">else</span> {</div>
<div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;        vec-&gt;<a class="code" href="struct__vector.html#a4165a40cc39bfd874677299c943b290f">padding</a> = 1;</div>
<div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;    }</div>
<div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;    <span class="keywordflow">return</span> (<a class="code" href="struct__matrix.html">matrix</a>*)vec;</div>
<div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;}</div>
<div class="ttc" id="struct__matrix_html"><div class="ttname"><a href="struct__matrix.html">_matrix</a></div><div class="ttdoc">represents a matrix between matrix and vector they are able to be casted into one another ...</div><div class="ttdef"><b>Definition:</b> linalg.h:40</div></div>
<div class="ttc" id="struct__vector_html_a4165a40cc39bfd874677299c943b290f"><div class="ttname"><a href="struct__vector.html#a4165a40cc39bfd874677299c943b290f">_vector::padding</a></div><div class="ttdeci">size_t padding</div><div class="ttdoc">unused value but important as padding </div><div class="ttdef"><b>Definition:</b> linalg.h:31</div></div>
<div class="ttc" id="struct__vector_html_a1ed8dca78f3e589deb8dad9b53aec3fa"><div class="ttname"><a href="struct__vector.html#a1ed8dca78f3e589deb8dad9b53aec3fa">_vector::size</a></div><div class="ttdeci">size_t size</div><div class="ttdoc">the number of elements in the vector </div><div class="ttdef"><b>Definition:</b> linalg.h:29</div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a4af2cd71186eeb14f970f97a27fbcef0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="linalg_8h.html#a07a01529159cc35e78c1f7731ac7bda6">vector</a>* vecmat_multiply </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="linalg_8h.html#a07a01529159cc35e78c1f7731ac7bda6">vector</a> *&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="linalg_8h.html#abc75382643898dd572498a574bf891c7">matrix</a> *&#160;</td>
          <td class="paramname"><em>mat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs vector matrix multiplication this function will malloc for the user a vector* if the vector is of size M and the matrix size M by N, the resulting column vector will be of size N. </p>
<dl class="section return"><dt>Returns</dt><dd>vector* newly malloced result of vector matrix multiplication </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>const vector* the input vector </td></tr>
    <tr><td class="paramname">mat</td><td>const matrix* the input matrix </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="struct__matrix.html#a7e9feb52cfc0a9d7cba5320abcaa997a">_matrix::col</a>, <a class="el" href="struct__vector.html#abcf7d1342126a90769b2a05126897859">_vector::data</a>, <a class="el" href="linalg_8h.html#ae0e32e641b8137c777d52988864296e3">MAT</a>, <a class="el" href="struct__matrix.html#a1087bec6a11b0773b4852c4ca49fc32a">_matrix::row</a>, <a class="el" href="struct__vector.html#a1ed8dca78f3e589deb8dad9b53aec3fa">_vector::size</a>, <a class="el" href="linalg_8h.html#a03e904294c904b01194a25323fc2f6ec">VEC</a>, and <a class="el" href="linalg_8c.html#a7040be230e99648e77b0932600bf55ef">vector_create()</a>.</p>
<div class="fragment"><div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;                                                               {</div>
<div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;    <span class="keywordflow">if</span>(vec == NULL  || mat == NULL) {</div>
<div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;        <span class="keywordflow">return</span> NULL;</div>
<div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;    }</div>
<div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;    <a class="code" href="struct__vector.html">vector</a>* retval = <a class="code" href="linalg_8c.html#a7040be230e99648e77b0932600bf55ef">vector_create</a>(vec-&gt;<a class="code" href="struct__vector.html#a1ed8dca78f3e589deb8dad9b53aec3fa">size</a>);</div>
<div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;    memset(retval-&gt;<a class="code" href="struct__vector.html#abcf7d1342126a90769b2a05126897859">data</a>, 0, <span class="keyword">sizeof</span>(<span class="keywordtype">double</span>) * vec-&gt;<a class="code" href="struct__vector.html#a1ed8dca78f3e589deb8dad9b53aec3fa">size</a>);</div>
<div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;    <span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> j = 0; j &lt; mat-&gt;<a class="code" href="struct__matrix.html#a7e9feb52cfc0a9d7cba5320abcaa997a">col</a>; j ++) {</div>
<div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;        <span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> i = 0; i &lt; mat-&gt;<a class="code" href="struct__matrix.html#a1087bec6a11b0773b4852c4ca49fc32a">row</a>; i ++) {</div>
<div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;            <a class="code" href="linalg_8h.html#a03e904294c904b01194a25323fc2f6ec">VEC</a>(retval, j) += (<a class="code" href="linalg_8h.html#a03e904294c904b01194a25323fc2f6ec">VEC</a>(vec, i) * <a class="code" href="linalg_8h.html#ae0e32e641b8137c777d52988864296e3">MAT</a>(mat, i, j));</div>
<div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;        }</div>
<div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;    }</div>
<div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;    <span class="keywordflow">return</span> retval;</div>
<div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;}</div>
<div class="ttc" id="struct__vector_html_abcf7d1342126a90769b2a05126897859"><div class="ttname"><a href="struct__vector.html#abcf7d1342126a90769b2a05126897859">_vector::data</a></div><div class="ttdeci">double data[]</div><div class="ttdoc">the elements of the vector </div><div class="ttdef"><b>Definition:</b> linalg.h:33</div></div>
<div class="ttc" id="linalg_8c_html_a7040be230e99648e77b0932600bf55ef"><div class="ttname"><a href="linalg_8c.html#a7040be230e99648e77b0932600bf55ef">vector_create</a></div><div class="ttdeci">vector * vector_create(size_t size)</div><div class="ttdoc">Creates a vector this function will malloc the exact space for the required dimensions. </div><div class="ttdef"><b>Definition:</b> linalg.c:11</div></div>
<div class="ttc" id="linalg_8h_html_a03e904294c904b01194a25323fc2f6ec"><div class="ttname"><a href="linalg_8h.html#a03e904294c904b01194a25323fc2f6ec">VEC</a></div><div class="ttdeci">#define VEC(v, x)</div><div class="ttdoc">macro for element access in a vector struct </div><div class="ttdef"><b>Definition:</b> linalg.h:19</div></div>
<div class="ttc" id="struct__matrix_html_a1087bec6a11b0773b4852c4ca49fc32a"><div class="ttname"><a href="struct__matrix.html#a1087bec6a11b0773b4852c4ca49fc32a">_matrix::row</a></div><div class="ttdeci">size_t row</div><div class="ttdoc">the number of rows in the matrix </div><div class="ttdef"><b>Definition:</b> linalg.h:42</div></div>
<div class="ttc" id="struct__matrix_html_a7e9feb52cfc0a9d7cba5320abcaa997a"><div class="ttname"><a href="struct__matrix.html#a7e9feb52cfc0a9d7cba5320abcaa997a">_matrix::col</a></div><div class="ttdeci">size_t col</div><div class="ttdoc">the number of columns in the matrix </div><div class="ttdef"><b>Definition:</b> linalg.h:44</div></div>
<div class="ttc" id="struct__vector_html_a1ed8dca78f3e589deb8dad9b53aec3fa"><div class="ttname"><a href="struct__vector.html#a1ed8dca78f3e589deb8dad9b53aec3fa">_vector::size</a></div><div class="ttdeci">size_t size</div><div class="ttdoc">the number of elements in the vector </div><div class="ttdef"><b>Definition:</b> linalg.h:29</div></div>
<div class="ttc" id="linalg_8h_html_ae0e32e641b8137c777d52988864296e3"><div class="ttname"><a href="linalg_8h.html#ae0e32e641b8137c777d52988864296e3">MAT</a></div><div class="ttdeci">#define MAT(m, x, y)</div><div class="ttdoc">macro for element access in a matrix struct </div><div class="ttdef"><b>Definition:</b> linalg.h:17</div></div>
<div class="ttc" id="struct__vector_html"><div class="ttname"><a href="struct__vector.html">_vector</a></div><div class="ttdoc">represents a vector padding is to make sure that matrix and vector both have the same byte size and a...</div><div class="ttdef"><b>Definition:</b> linalg.h:27</div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a2bc6dcc923c28a9d6f0ff38bd5de55f5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="linalg_8h.html#a07a01529159cc35e78c1f7731ac7bda6">vector</a>* vecscalar_divide </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="linalg_8h.html#a07a01529159cc35e78c1f7731ac7bda6">vector</a> *&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>scalar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs scalar division of a vector this function will malloc for the user a vector*. </p>
<dl class="section return"><dt>Returns</dt><dd>vector* that is the result of element wise division of the vector by the scalar </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>const vector* the input vector </td></tr>
    <tr><td class="paramname">scalar</td><td>const double the input scalar </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="linalg_8c.html#a0c350b8673e50738602aa10cd6a86924">vecscalar_multiply()</a>.</p>
<div class="fragment"><div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;                                                                 {</div>
<div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="linalg_8c.html#a0c350b8673e50738602aa10cd6a86924">vecscalar_multiply</a>(vec, 1 / scalar);</div>
<div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;}</div>
<div class="ttc" id="linalg_8c_html_a0c350b8673e50738602aa10cd6a86924"><div class="ttname"><a href="linalg_8c.html#a0c350b8673e50738602aa10cd6a86924">vecscalar_multiply</a></div><div class="ttdeci">vector * vecscalar_multiply(const vector *vec, const double scalar)</div><div class="ttdoc">Performs scalar multiplication of a vector this function will malloc for the user a vector*...</div><div class="ttdef"><b>Definition:</b> linalg.c:66</div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a0c350b8673e50738602aa10cd6a86924"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="linalg_8h.html#a07a01529159cc35e78c1f7731ac7bda6">vector</a>* vecscalar_multiply </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="linalg_8h.html#a07a01529159cc35e78c1f7731ac7bda6">vector</a> *&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>scalar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs scalar multiplication of a vector this function will malloc for the user a vector*. </p>
<dl class="section return"><dt>Returns</dt><dd>vector* that is the result of element wise multiplication of the vector by the scalar </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>const vector* the input vector </td></tr>
    <tr><td class="paramname">scalar</td><td>const double the input scalar </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="struct__vector.html#a1ed8dca78f3e589deb8dad9b53aec3fa">_vector::size</a>, <a class="el" href="linalg_8h.html#a03e904294c904b01194a25323fc2f6ec">VEC</a>, and <a class="el" href="linalg_8c.html#a7040be230e99648e77b0932600bf55ef">vector_create()</a>.</p>

<p>Referenced by <a class="el" href="linalg_8h.html#a2bc6dcc923c28a9d6f0ff38bd5de55f5">vecscalar_divide()</a>.</p>
<div class="fragment"><div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;                                                                   {</div>
<div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;    <a class="code" href="struct__vector.html">vector</a>* retval = <a class="code" href="linalg_8c.html#a7040be230e99648e77b0932600bf55ef">vector_create</a>(vec-&gt;<a class="code" href="struct__vector.html#a1ed8dca78f3e589deb8dad9b53aec3fa">size</a>);</div>
<div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; retval-&gt;<a class="code" href="struct__vector.html#a1ed8dca78f3e589deb8dad9b53aec3fa">size</a>; i ++) {</div>
<div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;        <a class="code" href="linalg_8h.html#a03e904294c904b01194a25323fc2f6ec">VEC</a>(retval, i) = <a class="code" href="linalg_8h.html#a03e904294c904b01194a25323fc2f6ec">VEC</a>(vec, i) * scalar;</div>
<div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;    }</div>
<div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;    <span class="keywordflow">return</span> retval; </div>
<div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;}</div>
<div class="ttc" id="linalg_8c_html_a7040be230e99648e77b0932600bf55ef"><div class="ttname"><a href="linalg_8c.html#a7040be230e99648e77b0932600bf55ef">vector_create</a></div><div class="ttdeci">vector * vector_create(size_t size)</div><div class="ttdoc">Creates a vector this function will malloc the exact space for the required dimensions. </div><div class="ttdef"><b>Definition:</b> linalg.c:11</div></div>
<div class="ttc" id="linalg_8h_html_a03e904294c904b01194a25323fc2f6ec"><div class="ttname"><a href="linalg_8h.html#a03e904294c904b01194a25323fc2f6ec">VEC</a></div><div class="ttdeci">#define VEC(v, x)</div><div class="ttdoc">macro for element access in a vector struct </div><div class="ttdef"><b>Definition:</b> linalg.h:19</div></div>
<div class="ttc" id="struct__vector_html_a1ed8dca78f3e589deb8dad9b53aec3fa"><div class="ttname"><a href="struct__vector.html#a1ed8dca78f3e589deb8dad9b53aec3fa">_vector::size</a></div><div class="ttdeci">size_t size</div><div class="ttdoc">the number of elements in the vector </div><div class="ttdef"><b>Definition:</b> linalg.h:29</div></div>
<div class="ttc" id="struct__vector_html"><div class="ttname"><a href="struct__vector.html">_vector</a></div><div class="ttdoc">represents a vector padding is to make sure that matrix and vector both have the same byte size and a...</div><div class="ttdef"><b>Definition:</b> linalg.h:27</div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a7040be230e99648e77b0932600bf55ef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="linalg_8h.html#a07a01529159cc35e78c1f7731ac7bda6">vector</a>* vector_create </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a vector this function will malloc the exact space for the required dimensions. </p>
<dl class="section return"><dt>Returns</dt><dd>vector* the newly malloced vector </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>size_t the desired number of elements in the vecrtor </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="struct__vector.html#a4165a40cc39bfd874677299c943b290f">_vector::padding</a>, and <a class="el" href="struct__vector.html#a1ed8dca78f3e589deb8dad9b53aec3fa">_vector::size</a>.</p>

<p>Referenced by <a class="el" href="linalg_8h.html#a71f490da601d057f4ce45efb9a48c2ae">compute_average()</a>, <a class="el" href="linalg_8h.html#af88415d8996030537851e2c48d5337c4">matvec_multiply()</a>, <a class="el" href="tiff__util_8h.html#a62e9f072f6cc2973ba744946e6a4c5c3">tiff_to_vec()</a>, <a class="el" href="linalg_8h.html#adbfad21fe7e851455d625173e67b8504">vec_append()</a>, <a class="el" href="linalg_8h.html#a4af2cd71186eeb14f970f97a27fbcef0">vecmat_multiply()</a>, and <a class="el" href="linalg_8h.html#a0c350b8673e50738602aa10cd6a86924">vecscalar_multiply()</a>.</p>
<div class="fragment"><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;                                   {</div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;    <span class="keywordflow">if</span>(size &lt;= 0) {</div>
<div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;        <span class="keywordflow">return</span> NULL;</div>
<div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;    }</div>
<div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;    <a class="code" href="struct__vector.html">vector</a>* retval = malloc((size * <span class="keyword">sizeof</span>(<span class="keywordtype">double</span>)) + (2 * <span class="keyword">sizeof</span>(<span class="keywordtype">size_t</span>)));</div>
<div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;    retval-&gt;<a class="code" href="struct__vector.html#a1ed8dca78f3e589deb8dad9b53aec3fa">size</a> = size;</div>
<div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;    retval-&gt;<a class="code" href="struct__vector.html#a4165a40cc39bfd874677299c943b290f">padding</a>  = 0;</div>
<div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;    <span class="keywordflow">return</span> retval;</div>
<div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;}</div>
<div class="ttc" id="struct__vector_html_a4165a40cc39bfd874677299c943b290f"><div class="ttname"><a href="struct__vector.html#a4165a40cc39bfd874677299c943b290f">_vector::padding</a></div><div class="ttdeci">size_t padding</div><div class="ttdoc">unused value but important as padding </div><div class="ttdef"><b>Definition:</b> linalg.h:31</div></div>
<div class="ttc" id="struct__vector_html_a1ed8dca78f3e589deb8dad9b53aec3fa"><div class="ttname"><a href="struct__vector.html#a1ed8dca78f3e589deb8dad9b53aec3fa">_vector::size</a></div><div class="ttdeci">size_t size</div><div class="ttdoc">the number of elements in the vector </div><div class="ttdef"><b>Definition:</b> linalg.h:29</div></div>
<div class="ttc" id="struct__vector_html"><div class="ttname"><a href="struct__vector.html">_vector</a></div><div class="ttdoc">represents a vector padding is to make sure that matrix and vector both have the same byte size and a...</div><div class="ttdef"><b>Definition:</b> linalg.h:27</div></div>
</div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Dec 19 2017 23:55:59 for Facial Recognition by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
